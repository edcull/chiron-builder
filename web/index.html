<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Awakening Chiron - Character Creator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --bg-dark: #0a0f14;
            --bg-panel: #131a22;
            --bg-input: #1a232d;
            --border: #2a3a4a;
            --accent: #4a9eff;
            --accent-dim: #2a5a8a;
            --text: #e0e8f0;
            --text-dim: #8090a0;
            --success: #4aff9f;
            --warning: #ffaa4a;
            --error: #ff4a6a;
            --faction-bonus: #d4af37;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.5;
            font-size: 16px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
        }
        
        header {
            text-align: center;
            padding: 20px 10px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: clamp(1.5em, 5vw, 2.5em);
            color: var(--accent);
            letter-spacing: 2px;
            margin-bottom: 8px;
        }
        
        h1 span {
            color: var(--text);
        }
        
        .subtitle {
            color: var(--text-dim);
            font-style: italic;
            font-size: 0.9em;
            display: none;
        }
        
        @media (min-width: 600px) {
            .subtitle { display: block; }
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }
        
        @media (min-width: 900px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
                gap: 20px;
            }
        }
        
        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 0;
        }
        
        .panel h2 {
            color: var(--accent);
            font-size: 1.1em;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .form-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            color: var(--text-dim);
            margin-bottom: 5px;
            font-size: 0.85em;
        }
        
        input[type="text"], select, textarea {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 16px; /* Prevents zoom on iOS */
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        select {
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%238090a0' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 35px;
        }
        
        textarea {
            resize: vertical;
            min-height: 60px;
            transition: min-height 0.2s ease;
        }
        
        textarea#charConcept:focus {
            min-height: 200px;
        }
        
        .char-counter {
            font-size: 0.75em;
            color: var(--text-dim);
            font-weight: normal;
        }
        
        .char-counter.warning {
            color: var(--warning);
        }
        
        .char-counter.danger {
            color: var(--danger);
        }
        
        .ideology-display {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }
        
        .ideology-display.faction-ideologies {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .ideology-row {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .ideology-row .ideology-tag {
            flex: 1 1 auto;
        }
        
        .ideology-tag {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            background: var(--accent-dim);
            text-align: center;
            white-space: nowrap;
        }
        
        .ideology-tag.dominant {
            background: var(--success);
            color: #000;
        }
        
        .ideology-tag.strong {
            background: var(--accent);
            color: #000;
        }
        
        .ideology-tag.weak {
            background: var(--error);
            color: #fff;
            opacity: 0.7;
        }
        
        .proficiency-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 10px;
            max-height: 350px;
            overflow-y: auto;
            padding: 8px;
            background: var(--bg-input);
            border-radius: 4px;
            -webkit-overflow-scrolling: touch;
        }
        
        .proficiency-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px;
            background: var(--bg-panel);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
            border: 1px solid transparent;
        }
        
        .proficiency-item.unfavoured {
            border-left: 3px solid #888;
        }
        
        .proficiency-item.unfavoured.selected {
            background: rgba(255, 255, 255, 0.15);
            border-color: #fff;
            border-left: 3px solid #fff;
        }
        
        .proficiency-item.unfavoured.selected .prof-name {
            color: #fff;
        }
        
        .proficiency-item.aversion {
            border-left: 3px solid var(--error);
        }
        
        .proficiency-item.aversion.selected {
            background: rgba(255, 74, 106, 0.15);
            border-color: var(--error);
            border-left: 3px solid var(--error);
        }
        
        .proficiency-item.aversion.selected .prof-name {
            color: var(--error);
        }
        
        .prof-cost {
            color: var(--warning);
            font-size: 0.85em;
            font-weight: normal;
        }
        
        .proficiency-item input[type="checkbox"] {
            margin-top: 2px;
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .prof-details {
            display: flex;
            flex-direction: column;
            gap: 3px;
            flex: 1;
            min-width: 0;
        }
        
        .prof-name {
            font-weight: 500;
            color: var(--text);
        }
        
        .prof-desc {
            font-size: 0.85em;
            color: var(--text-dim);
            line-height: 1.4;
        }
        
        .proficiency-item:hover {
            background: var(--border);
        }
        
        .proficiency-item.selected {
            background: var(--accent-dim);
            border-color: var(--accent);
        }
        
        .proficiency-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .proficiency-item.faction-bonus {
            background: rgba(212, 175, 55, 0.2);
            border-color: var(--faction-bonus);
        }
        
        .proficiency-item.faction-bonus .prof-name::after {
            content: ' ★';
            color: var(--faction-bonus);
        }
        
        .selected-proficiencies {
            margin-top: 12px;
        }
        
        .selected-prof-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .selected-prof {
            padding: 5px 10px;
            background: var(--accent-dim);
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
        }
        
        .selected-prof.faction-bonus {
            background: rgba(212, 175, 55, 0.3);
            border: 1px solid var(--faction-bonus);
        }
        
        .selected-prof.unfavoured {
            background: rgba(128, 128, 128, 0.3);
            border: 1px solid #fff;
        }
        
        .selected-prof.aversion {
            background: rgba(255, 74, 106, 0.3);
            border: 1px solid var(--error);
        }
        
        .selected-prof.versatile {
            background: rgba(180, 100, 255, 0.3);
            border: 1px solid #b464ff;
        }
        
        .selected-prof.versatile .remove {
            display: none;
        }
        
        .selected-prof.granted {
            background: rgba(180, 100, 255, 0.3);
            border: 1px solid #b464ff;
        }
        
        .selected-prof.granted .remove {
            display: none;
        }
        
        .selected-prof .remove {
            cursor: pointer;
            color: var(--error);
            font-weight: bold;
            font-size: 1.1em;
            line-height: 1;
        }
        
        .selected-prof.faction-bonus .remove {
            display: none;
        }
        
        .advantage-item, .drawback-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
            padding: 10px;
            margin-bottom: 6px;
            background: var(--bg-input);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .advantage-item:hover, .drawback-item:hover {
            background: var(--border);
        }
        
        .advantage-item.selected {
            background: rgba(74, 255, 159, 0.15);
            border-color: var(--success);
        }
        
        .drawback-item.selected {
            background: rgba(255, 74, 106, 0.15);
            border-color: var(--error);
        }
        
        .advantage-item.disabled, .drawback-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .advantage-item.faction-bonus {
            background: rgba(212, 175, 55, 0.2);
            border-color: var(--faction-bonus);
        }
        
        .advantage-item.faction-bonus .adv-name::after {
            content: ' ★';
            color: var(--faction-bonus);
        }
        
        .adv-content {
            flex: 1;
            min-width: 0;
        }
        
        .adv-name {
            font-weight: 500;
            font-size: 0.95em;
        }
        
        .adv-cost {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.85em;
            min-width: 35px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .advantage-item .adv-cost {
            background: var(--success);
            color: #000;
        }
        
        .advantage-item.faction-bonus .adv-cost {
            background: var(--faction-bonus);
            color: #000;
        }
        
        .drawback-item .adv-cost {
            background: var(--error);
            color: #fff;
        }
        
        .adv-description {
            font-size: 0.8em;
            color: var(--text-dim);
            margin-top: 4px;
            line-height: 1.4;
        }
        
        .adv-prereq {
            font-size: 0.75em;
            color: var(--warning);
            margin-top: 3px;
            font-style: italic;
        }
        
        .adv-effect {
            font-size: 0.75em;
            color: var(--accent);
            margin-top: 3px;
        }
        
        .xp-tracker {
            display: flex;
            flex-direction: row;
            gap: 15px;
            padding: 12px;
            background: var(--bg-input);
            border-radius: 4px;
            margin-bottom: 12px;
            align-items: center;
            justify-content: space-between;
        }
        
        .xp-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .xp-item.net {
            border-left: 1px solid var(--border);
            padding-left: 15px;
        }
        
        .xp-value {
            font-size: 1.3em;
            font-weight: bold;
            order: 2;
        }
        
        .xp-label {
            font-size: 0.7em;
            color: var(--text-dim);
            order: 1;
        }
        
        .validation-message {
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 0.85em;
        }
        
        .validation-message.error {
            background: rgba(255, 74, 106, 0.2);
            border: 1px solid var(--error);
            color: var(--error);
        }
        
        .validation-message.success {
            background: rgba(74, 255, 159, 0.2);
            border: 1px solid var(--success);
            color: var(--success);
        }
        
        .validation-message.warning {
            background: rgba(255, 170, 74, 0.2);
            border: 1px solid var(--warning);
            color: var(--warning);
        }
        
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 500;
            transition: all 0.2s;
            touch-action: manipulation;
        }
        
        .btn-primary {
            background: var(--accent);
            color: #000;
        }
        
        .btn-primary:hover {
            background: var(--success);
        }
        
        .btn-pdf {
            background: var(--warning);
            color: #000;
        }
        
        .btn-pdf:hover {
            background: #ffcc66;
        }
        
        .btn-secondary {
            background: var(--bg-input);
            color: var(--text);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            border-color: var(--accent);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 15px;
        }
        
        .button-group .btn {
            padding: 10px 12px;
        }
        
        @media (min-width: 400px) {
            .button-group {
                display: flex;
                flex-wrap: wrap;
            }
            .button-group .btn {
                flex: 1;
                min-width: 80px;
            }
        }
        
        .summary-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        
        @media (min-width: 500px) {
            .summary-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .summary-item {
            padding: 10px;
            background: var(--bg-input);
            border-radius: 4px;
        }
        
        .summary-item h4 {
            color: var(--accent);
            margin-bottom: 5px;
            font-size: 0.8em;
        }
        
        .summary-item div {
            font-size: 0.9em;
        }
        
        .collapsible {
            cursor: pointer;
            user-select: none;
        }
        
        .collapsible::after {
            content: ' ▼';
            font-size: 0.7em;
        }
        
        .collapsible.collapsed::after {
            content: ' ▶';
        }
        
        .collapse-content {
            max-height: 500px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
            -webkit-overflow-scrolling: touch;
        }
        
        .collapse-content.collapsed {
            max-height: 0;
            overflow: hidden;
        }
        
        .requirements-check {
            list-style: none;
            margin: 10px 0;
            font-size: 0.85em;
        }
        
        .requirements-check li {
            padding: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .requirements-check .check {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            flex-shrink: 0;
        }
        
        .requirements-check .check.pass {
            background: var(--success);
            color: #000;
        }
        
        .requirements-check .check.fail {
            background: var(--error);
            color: #fff;
        }
        
        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 8px;
            margin-bottom: 10px;
        }
        
        .tab {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid transparent;
            color: var(--primary);
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            font-size: 0.85em;
            white-space: nowrap;
        }
        
        .tab.active {
            background: var(--bg-input);
            border-color: var(--primary);
            border-bottom-color: var(--bg-panel);
            color: var(--primary);
        }
        
        .tab.unfavoured {
            color: #888;
        }
        
        .tab.unfavoured.active {
            color: #fff;
            border-color: #fff;
            border-bottom-color: var(--bg-panel);
            background: var(--bg-input);
        }
        
        .tab.bonus {
            color: var(--faction-bonus);
        }
        
        .tab.bonus.active {
            color: var(--faction-bonus);
            border-color: var(--faction-bonus);
            border-bottom-color: var(--bg-panel);
            background: var(--bg-input);
        }
        
        .tab.aversion {
            color: var(--error);
        }
        
        .tab.aversion.active {
            color: var(--error);
            border-color: var(--error);
            border-bottom-color: var(--bg-panel);
            background: var(--bg-input);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .faction-info {
            margin-top: 10px;
            padding: 10px;
            background: var(--bg-input);
            border-radius: 4px;
            font-size: 0.85em;
        }
        
        .faction-info p {
            margin-bottom: 6px;
            color: var(--text-dim);
        }
        
        .faction-bonus-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(212, 175, 55, 0.15);
            border: 1px solid var(--faction-bonus);
            border-radius: 4px;
            font-size: 0.85em;
        }
        
        .faction-bonus-info h4 {
            color: var(--faction-bonus);
            margin-bottom: 6px;
            font-size: 0.95em;
        }
        
        .faction-bonus-info p {
            color: var(--text);
            margin-bottom: 4px;
        }
        
        .faction-bonus-info .bonus-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 4px;
            color: var(--text-dim);
        }
        
        .faction-bonus-info .bonus-item::before {
            content: '★';
            color: var(--faction-bonus);
        }
        
        .ideology-description {
            margin-top: 8px;
            padding: 10px;
            background: var(--bg-input);
            border-radius: 4px;
            font-size: 0.8em;
            line-height: 1.5;
            display: none;
        }
        
        .ideology-description.visible {
            display: block;
        }
        
        .ideology-description .belief-text {
            color: var(--success);
            margin-bottom: 5px;
        }
        
        .ideology-description .opposition-text {
            color: var(--error);
            opacity: 0.8;
        }
        
        .counter {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            background: var(--bg-input);
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: normal;
        }
        
        .counter.valid {
            color: var(--success);
        }
        
        .counter.invalid {
            color: var(--error);
        }
        
        .counter.warning {
            color: var(--warning);
        }
        
        .effect-notice {
            margin-top: 10px;
            padding: 8px 10px;
            background: rgba(74, 158, 255, 0.15);
            border: 1px solid var(--accent);
            border-radius: 4px;
            font-size: 0.8em;
            color: var(--accent);
        }
        
        /* Mobile optimizations */
        @media (max-width: 500px) {
            .container {
                padding: 10px;
            }
            
            .panel {
                padding: 12px;
            }
            
            .xp-tracker {
                flex-direction: column;
                gap: 8px;
                padding: 10px 12px;
            }
            
            .xp-item {
                flex-direction: row;
                justify-content: space-between;
                width: 100%;
                padding: 4px 0;
            }
            
            .xp-item.net {
                border-left: none;
                border-top: 1px solid var(--border);
                padding-left: 0;
                padding-top: 8px;
                margin-top: 4px;
            }
            
            .xp-label {
                font-size: 0.85em;
                order: 1;
                text-align: left;
            }
            
            .xp-value {
                order: 2;
                text-align: right;
            }
            
            .button-group .btn {
                padding: 12px 10px;
            }
            
            .tab {
                padding: 5px 8px;
                font-size: 0.8em;
            }
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-dim);
        }
        
        /* Choice selector styles */
        .choice-selector {
            margin-top: 8px;
            padding: 8px;
            background: var(--bg-dark);
            border-radius: 4px;
            border: 1px solid var(--border);
        }
        
        .choice-selector label {
            display: block;
            color: var(--warning);
            font-size: 0.75em;
            margin-bottom: 4px;
        }
        
        .choice-selector select,
        .choice-selector input[type="text"] {
            width: 100%;
            padding: 6px 8px;
            font-size: 0.85em;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 3px;
            color: var(--text);
        }
        
        .choice-selector select:focus,
        .choice-selector input[type="text"]:focus {
            border-color: var(--accent);
            outline: none;
        }
        
        .choice-selector .choice-desc {
            font-size: 0.7em;
            color: var(--text-dim);
            margin-top: 3px;
        }
        
        .choice-warning {
            color: var(--warning);
            font-size: 0.75em;
            margin-top: 4px;
        }
        
        /* Rising Star special multi-select */
        .rising-star-choices {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .rising-star-choices .choice-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .rising-star-choices .choice-row label {
            min-width: 80px;
            margin-bottom: 0;
        }
        
        .rising-star-choices .choice-row select {
            flex: 1;
        }
        
        /* Practiced multiple instances */
        .practiced-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .practiced-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .practiced-item select {
            flex: 1;
        }
        
        .practiced-item .remove-practiced {
            color: var(--error);
            cursor: pointer;
            font-weight: bold;
            padding: 2px 6px;
        }
        
        /* Inline choice indicator */
        .has-choice-required::after {
            content: ' ⚙';
            color: var(--warning);
        }
        
        .choice-complete::after {
            content: ' ✓';
            color: var(--success);
        }
        
        /* Multiple instance controls */
        .adv-cost-area {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }
        
        .multiple-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .multi-btn {
            width: 22px;
            height: 22px;
            padding: 0;
            border: 1px solid var(--border);
            background: var(--bg-input);
            color: var(--text);
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .multi-btn:hover:not(:disabled) {
            border-color: var(--accent);
            background: var(--bg-light);
        }
        
        .multi-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .multi-count {
            min-width: 20px;
            text-align: center;
            font-weight: bold;
            color: var(--accent);
        }
        
        /* Proficiency multiple controls */
        .prof-multiple-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
            padding-left: 8px;
        }
        
        .proficiency-item {
            display: flex;
            align-items: flex-start;
        }
        
        .proficiency-item .prof-details {
            flex: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>AWAKENING <span>CHIRON</span></h1>
            <p class="subtitle">Character Builder Version 0.21</p>
        </header>
        
        <div class="main-grid">
            <div class="left-column">
                <!-- Basic Info -->
                <div class="panel">
                    <h2>Character Basics</h2>
                    <div class="form-group">
                        <label for="charName">Character Name</label>
                        <input type="text" id="charName" placeholder="Enter character name">
                    </div>
                    <div class="form-group">
                        <label for="charConcept">Character Concept <span id="conceptCounter" class="char-counter"></span></label>
                        <textarea id="charConcept" rows="2" maxlength="1200" placeholder="Brief description of your character concept"></textarea>
                    </div>
                </div>
                
                <!-- Faction Selection -->
                <div class="panel">
                    <h2>Faction</h2>
                    <div class="form-group">
                        <label for="faction">Select Faction</label>
                        <select id="faction">
                            <option value="">-- Choose Faction --</option>
                            <option value="believers">The Believers</option>
                            <option value="gaians">Gaia's Stepchildren</option>
                            <option value="hive">Human Hive</option>
                            <option value="morgan">Morgan Industries</option>
                            <option value="spartans">The Spartans</option>
                            <option value="peacekeepers">UN Peacekeepers</option>
                            <option value="university">University of Planet</option>
                        </select>
                    </div>
                    <div id="factionInfo" class="faction-info" style="display:none;"></div>
                    <div id="factionBonusInfo" class="faction-bonus-info" style="display:none;"></div>
                    <div id="factionIdeologies" class="ideology-display faction-ideologies"></div>
                </div>
                
                <!-- Ideologies -->
                <div class="panel">
                    <h2>Ideologies</h2>
                    
                    <div class="form-group">
                        <label>Faction Ideology (Determined by Faction)</label>
                        <div id="factionIdeology" class="ideology-display">
                            <span class="ideology-tag" style="opacity:0.5">Select a faction first</span>
                        </div>
                        <div id="factionRebelSelect" class="form-group" style="display:none; margin-top: 10px;">
                            <label for="customFactionIdeology">Choose Different Faction Ideology (Faction Rebel)</label>
                            <select id="customFactionIdeology">
                                <option value="">-- Use Default --</option>
                            </select>
                        </div>
                        <div id="factionIdeologyDesc" class="ideology-description"></div>
                    </div>
                    
                    <div class="form-group">
                        <label for="roleIdeology">Role Ideology</label>
                        <select id="roleIdeology" disabled>
                            <option value="">-- Select faction first --</option>
                        </select>
                        <div id="roleIdeologyDesc" class="ideology-description"></div>
                    </div>
                    
                    <div class="form-group">
                        <label for="beliefIdeology">Belief Ideology</label>
                        <select id="beliefIdeology" disabled>
                            <option value="">-- Select role first --</option>
                        </select>
                        <div id="beliefIdeologyDesc" class="ideology-description"></div>
                    </div>
                    
                    <div class="form-group">
                        <label for="aversionIdeology">Aversion Ideology</label>
                        <select id="aversionIdeology" disabled>
                            <option value="">-- Select belief first --</option>
                        </select>
                        <div id="aversionIdeologyDesc" class="ideology-description"></div>
                    </div>
                    
                    <div id="secondaryIdeologies" style="display: none;">
                        <div class="form-group">
                            <label for="secondBeliefIdeology">Second Belief Ideology (Ideologist)</label>
                            <select id="secondBeliefIdeology">
                                <option value="">-- Choose Second Belief --</option>
                            </select>
                            <div id="secondBeliefIdeologyDesc" class="ideology-description"></div>
                        </div>
                        <div class="form-group">
                            <label for="secondAversionIdeology">Second Aversion Ideology</label>
                            <select id="secondAversionIdeology">
                                <option value="">-- Choose Second Aversion --</option>
                            </select>
                            <div id="secondAversionIdeologyDesc" class="ideology-description"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Proficiencies -->
                <div class="panel">
                    <h2>Proficiencies <span class="counter" id="profCounter">(0/6)</span></h2>
                    
                    <div id="profEffects"></div>
                    
                    <div id="proficiencyRequirements" class="requirements-check"></div>
                    
                    <div class="tabs" id="profTabs"></div>
                    <div id="profTabContent"></div>
                    
                    <div class="selected-proficiencies">
                        <label>Selected Proficiencies:</label>
                        <div class="selected-prof-list" id="selectedProfs">
                            <span style="color: var(--text-dim); font-size: 0.9em;">None selected</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="right-column">
                <!-- XP Tracker -->
                <div class="panel">
                    <h2>XP Balance</h2>
                    <div class="xp-tracker">
                        <div class="xp-item">
                            <div class="xp-label">Proficiencies</div>
                            <div class="xp-value" id="profXP">0</div>
                        </div>
                        <div class="xp-item">
                            <div class="xp-label">Advantages</div>
                            <div class="xp-value" id="advXP">0</div>
                        </div>
                        <div class="xp-item">
                            <div class="xp-label">Drawbacks</div>
                            <div class="xp-value" id="drawXP">+0</div>
                        </div>
                        <div class="xp-item net">
                            <div class="xp-label">Net XP</div>
                            <div class="xp-value" id="netXP">0</div>
                        </div>
                    </div>
                </div>
                
                <!-- Advantages -->
                <div class="panel">
                    <h2 class="collapsible" onclick="toggleCollapse(this)">Advantages</h2>
                    <div class="collapse-content" id="advantagesList"></div>
                </div>
                
                <!-- Drawbacks -->
                <div class="panel">
                    <h2 class="collapsible" onclick="toggleCollapse(this)">Drawbacks</h2>
                    <div class="collapse-content" id="drawbacksList"></div>
                </div>
                
                <!-- Validation & Export -->
                <div class="panel">
                    <h2>Character Validation</h2>
                    <div id="validationMessages"></div>
                    
                    <div class="button-group">
                        <button class="btn btn-primary" id="exportBtn" onclick="exportCharacter()">Export JSON</button>
                        <button class="btn btn-pdf" id="exportPdfBtn" onclick="exportPDF()">Export PDF</button>
                        <button class="btn btn-secondary" onclick="importCharacter()">Import</button>
                        <button class="btn btn-secondary" id="resetBtn">Reset</button>
                    </div>
                    <input type="file" id="importFile" style="display:none" accept=".json" onchange="handleImport(event)">
                </div>
                
                <!-- Character Summary -->
                <div class="panel">
                    <h2>Character Summary</h2>
                    <div id="characterSummary"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Game Data
        const IDEOLOGIES = [
            'Decentralisation', 'Economy', 'Growth', 'Industry', 'Military',
            'Morale', 'Planet', 'Police', 'Probe', 'Research'
        ];
        
        const FACTIONS = {
            believers: {
                name: 'The Believers',
                leader: 'Miriam Godwinson',
                dominant: 'Morale',
                strong: ['Military', 'Probe'],
                weak: ['Planet', 'Research'],
                description: 'Compassionate, driven and extremely human-centric, the Believers maintain that a divine hand guides the survival and development of humanity.',
                bonusXP: 0,
                bonusProficiencies: [{ name: 'Strong-willed', ideology: 'Morale' }],
                bonusAdvantages: [],
                bonusDescription: 'Believers gain a bonus to resist the worsening of tolls through their unwavering faith.',
                startingIncome: 2,
                startingUpkeep: 0
            },
            gaians: {
                name: "Gaia's Stepchildren",
                leader: 'Deirdre Skye',
                dominant: 'Planet',
                strong: ['Decentralisation', 'Research'],
                weak: ['Military', 'Police'],
                description: 'Gaia\'s Stepchildren focus on both the moral and practical imperatives of an existence in harmony with the environment.',
                bonusXP: 0,
                bonusProficiencies: [{ name: 'Haven', ideology: 'Planet' }],
                bonusAdvantages: ['One With Nature'],
                bonusDescription: 'Gaians live in harmony with Chiron, gaining natural sanctuaries and an innate connection with native life.',
                startingIncome: 2,
                startingUpkeep: 0
            },
            hive: {
                name: 'Human Hive',
                leader: 'Sheng-Ji Yang',
                dominant: 'Police',
                strong: ['Growth', 'Industry'],
                weak: ['Decentralisation', 'Economy'],
                description: 'A collective built with a focus on self-control, security and the enlightened understanding that the needs of the community outweigh the needs of the individuals within it.',
                bonusXP: 0,
                bonusProficiencies: [{ name: 'Protect', ideology: 'Police' }],
                bonusAdvantages: [],
                bonusDescription: 'Hive citizens have their basic necessities provided by the state. Starting income and upkeep are both zero.',
                startingIncome: 0,
                startingUpkeep: 0
            },
            morgan: {
                name: 'Morgan Industries',
                leader: 'Nwabudike Morgan',
                dominant: 'Economy',
                strong: ['Industry', 'Probe'],
                weak: ['Planet', 'Growth'],
                description: 'Cutthroat, resourceful, and individualistic, Morganites know what they want and how to get it.',
                bonusXP: 0,
                bonusProficiencies: [{ name: 'Energy', ideology: 'Economy' }],
                bonusAdvantages: [],
                bonusDescription: 'Morganites have higher expenses but can leverage wealth for status. Regular upkeep is 2 energy, but a third and fourth can also be spent granting extra reputation each time, while spending only 1 costs reputation (-1) and spending none costs -3 reputation.',
                startingIncome: 2,
                startingUpkeep: 2
            },
            spartans: {
                name: 'The Spartans',
                leader: 'Corazon Santiago',
                dominant: 'Military',
                strong: ['Morale', 'Police'],
                weak: ['Growth', 'Industry'],
                description: 'The Spartans believe that the universe is a hostile place. Only the strong survive.',
                bonusXP: 0,
                bonusProficiencies: [{ name: 'Exterminate', ideology: 'Military' }],
                bonusAdvantages: [],
                bonusDescription: 'Spartans are trained warriors. Choose either Weapon OR Armour as an additional starting proficiency.',
                bonusChoiceProficiencies: [
                    { name: 'Weapon', ideology: 'Military' },
                    { name: 'Armour', ideology: 'Military' }
                ],
                startingIncome: 2,
                startingUpkeep: 0
            },
            peacekeepers: {
                name: 'UN Peacekeepers',
                leader: 'Pravin Lal',
                dominant: 'Decentralisation',
                strong: ['Economy', 'Growth'],
                weak: ['Police', 'Probe'],
                description: 'The Peacekeepers hold onto the Four Freedoms: speech, worship, freedom from want, freedom from fear.',
                bonusXP: 2,
                bonusProficiencies: [{ name: 'Facilitation', ideology: 'Decentralisation' }],
                bonusAdvantages: [],
                bonusDescription: 'UN Peacekeepers are skilled diplomats with additional resources. They gain +2 bonus XP which can be spent on advantages OR an extra proficiency from their Faction/Role/Belief ideologies (2 XP).',
                startingIncome: 2,
                startingUpkeep: 0
            },
            university: {
                name: 'University of Planet',
                leader: 'Prokhor Zakharov',
                dominant: 'Research',
                strong: ['Decentralisation', 'Industry'],
                weak: ['Morale', 'Probe'],
                description: 'The University devotes their time to rational, scientific inquiry into the wonders around them.',
                bonusXP: 0,
                bonusProficiencies: [{ name: 'Academics', ideology: 'Research' }],
                bonusAdvantages: ['Skilled'],
                bonusDescription: 'University members are highly educated, starting with academic knowledge and additional proficiency through their training.',
                startingIncome: 2,
                startingUpkeep: 0
            }
        };
        
        const IDEOLOGY_DESCRIPTIONS = {
            Decentralisation: { belief: 'Power should be distributed across society to allow each part to function independently.', opposition: 'Prefers strong central authority.' },
            Economy: { belief: 'The free market is the strongest engine for prosperity and should be encouraged.', opposition: 'Corporations should be heavily regulated or not exist.' },
            Growth: { belief: 'Population growth and expansion are key to humanity\'s survival.', opposition: 'Quality over quantity; growth causes suffering.' },
            Industry: { belief: 'Construction and production of goods are needed for humans to flourish.', opposition: 'Industry harms people or environment.' },
            Military: { belief: 'A strong military is key to safety, security and prosperity.', opposition: 'Pacifism and non-violent approaches.' },
            Morale: { belief: 'Strong faction belief; compromise and dissent are weakness.', opposition: 'Open-minded, welcoming other ideas.' },
            Planet: { belief: 'Living in harmony with Chiron and sustainable practices are best.', opposition: 'The world exists to be used for humanity.' },
            Police: { belief: 'Authoritarian control prevents disorder and promotes stability.', opposition: 'Anarchism or freedom advocacy.' },
            Probe: { belief: 'Information is power; secrets should be held responsibly.', opposition: 'Free sharing of knowledge for all.' },
            Research: { belief: 'New technologies ensure survival, whatever the cost.', opposition: 'Suspicious of new technologies.' }
        };

        const PROFICIENCIES = {
            Decentralisation: {
                'Administration': 'Turn a resource into two for downtime. Energy becomes any type; minerals/nutrients stay same.',
                'Ally': 'An ally supports one downtime action per cycle for a specific ideology you hold.',
                'Delegate': 'Support two additional facilities per level beyond standard.',
                'Facilitation': 'Counter sabotage with redraws. Support third-party meetings.',
                'Leadership': 'Lead military teams or coordinate bases. Allows Base Commander role.',
                'Influence': 'Change group policy or gain reputation. More rep = higher success.',
                'Support': 'Grant one card to another for their next appropriate check.'
            },
            Economy: {
                'Broadcast': 'Send info widely. Advertise, implement technology, spread rumours.',
                'Contract Law': 'Create or analyse binding agreements with solid legal clauses.',
                'Energy': '2 energy goods at session start. Can be traded.',
                'Larceny': 'Break locks, take items, make fraudulent deals.',
                'Invest': 'Turn a resource into two for downtime.',
                'Management': 'Support two additional facilities per level.',
                'Negotiate': 'Convince others to accept your point of view.'
            },
            Growth: {
                'Animal': 'Own/access terrestrial animals. Training and care skills.',
                'Community': 'Community supports one downtime action for a specific ideology.',
                'Expand': 'Lead a team to set up or expand a base.',
                'Medicine': 'Recover injuries or save from dying with skill check.',
                'Nutrients': '2 nutrient goods at session start. Can be traded.',
                'Survey': 'Examine terrain for features and base suitability.',
                'Terraform': 'Team that makes land suitable, enhancing sites or yield.'
            },
            Industry: {
                'Build': 'Team capable of constructing base facilities with goods.',
                'Craft': 'Create or upgrade equipment with appropriate goods.',
                'Exploit': 'Extract all resources from surveyed area.',
                'Factory': 'Workshops to turn minerals into goods or upgrade units.',
                'Minerals': '2 mineral goods at session start. Can be traded.',
                'Prototype': 'Test new tech in field. Create experimental equipment.',
                'Repair': 'Fix damaged systems, infrastructure, or facilities.'
            },
            Military: {
                'Armour': '(Equipment) Ignore 1 damage in dramatic scene. Needs upgrading.',
                'Athletics': 'Feats of strength or agility.',
                'Command': 'Lead military teams. Allows Base Commander role.',
                'Defend': 'Defend infrastructure/base in downtime, cover in session.',
                'Exterminate': 'Combat checks fighting enemies. Enhanced by weapons.',
                'Scout': 'Lead group into territory to find what\'s present.',
                'Weapon': '(Equipment) Extra damage in combat. Needs upgrading.'
            },
            Morale: {
                'Counselling': 'Bring character back from Shaken. Once per character per session.',
                'Follower': 'Adherents assist with downtime actions for their ideology.',
                'Incite': 'Make person/group act on ideologies or magnify existing ones.',
                'Inspire': 'Grant one card to another for their next check.',
                'Presence': 'Gain attention of the room.',
                'Strong-willed': 'Resist profile/interrogate. High levels give false readings.',
                'Train': 'Increase morale or training level of military unit.'
            },
            Planet: {
                'Dream': 'Communicate in dreams. Enter trance for direct contact.',
                'Explore': 'Lead group into territory to find what\'s present.',
                'Farm': '2 nutrient goods at session start. Can be traded.',
                'Haven': 'Secluded serenity area. Enhances dreams, lowers tolls.',
                'Seafaring': 'Lead team over water. Grants small naval vessel.',
                'Xenobiology': 'Understanding native life helps travel and study.',
                'Xenofungus': 'Understanding makes travel easier. Early warning of attacks.'
            },
            Police: {
                'Interrogate': 'Get information directly from another character.',
                'Investigate': 'Gain info about person/group/place through observation.',
                'Profile': 'Learn about role, beliefs, advantages, tolls. Needs conversation.',
                'Protect': 'Defend infrastructure in downtime, cover in session.',
                'Sleight of Hand': 'Covertly take/apply something. 1 damage without drama.',
                'Stoic': 'Resist profile/interrogate. High levels give false readings.',
                'Subdue': 'Non-lethal incapacitation.'
            },
            Probe: {
                'Contact': 'Datalinks contact for info or assist one downtime action.',
                'Cyberhack': 'Gain access to restricted info or systems.',
                'Data Scan': 'Collect/analyse datalinks info. Defends against hacking.',
                'Infiltrate': 'Place yourself/code in org. Temp rep or ongoing intel.',
                'Propaganda': 'Spread info or encourage/discourage ideology.',
                'Program': 'Create code. Manage 1 facility in downtime.',
                'Sabotage': '-3 card for others, or positive when damaging systems.'
            },
            Research: {
                'Academics': 'Info about technology or world/history facts.',
                'Analyse': 'Gain info about person/group/place through observation.',
                'Develop': 'Implement tech or turn breakthroughs into technology.',
                'Document': 'Publicise/record info, influencing research and ideologies.',
                'Lab': 'Produces one breakthrough per session. Can create tech.',
                'Mentor': 'Help someone learn proficiency you have. Can loan cards.',
                'Study': 'Examine item/breakthrough/artifact. May generate breakthrough.'
            }
        };
        
        const ADVANTAGES = [
            { name: 'Alternative Interpretation', cost: 5, desc: 'Can learn proficiencies from Aversion (non-favoured).', effect: 'proficiency' },
            { name: 'Base Commander', cost: 4, desc: 'In charge of a small outpost.', prereqNote: 'Requires Leadership or Command proficiency' },
            { name: 'Benefactor', cost: 2, desc: 'Wealthy backer pays living costs.', excludeFactions: ['hive'] },
            { name: 'Celebrity', cost: 4, desc: 'Famous - reputation +1 with known factions.' },
            { name: 'Common Sense', cost: 1, desc: 'Once per downtime, ask Refs if plan seems reasonable.' },
            { name: 'Contract Administrator', cost: 2, desc: 'Review contracts anytime.', prereqNote: 'Requires Decentralisation favoured OR Contract Law proficiency', prereqCheck: (s) => s.factionIdeology === 'Decentralisation' || s.roleIdeology === 'Decentralisation' || s.beliefIdeology === 'Decentralisation' || s.proficiencies.some(p => p.name === 'Contract Law') },
            { name: 'Datalink Files Deleted', cost: 3, desc: 'No evidence of past on datalinks.', prereqNote: 'Requires Probe as Belief or Aversion', prereqCheck: (s) => s.beliefIdeology === 'Probe' || s.aversionIdeology === 'Probe' },
            { name: 'Ear of the Leader', cost: 4, desc: 'Regular contact with high-ranking faction individual.' },
            { name: 'Earth Artifact', cost: 3, desc: 'Equipment from Earth.', creationOnly: true },
            { name: 'Earthling', cost: 4, desc: 'Original Unity crew. +1 rep with sub-group, two free proficiencies from favoured ideologies, starts with Toll.', creationOnly: true, effect: 'proficiency', effectDesc: '+2 free proficiencies (from favoured ideologies)' },
            { name: 'Energy Savings', cost: 3, desc: 'Gain Energy Proficiency (2 energy goods/session).', grantsProficiency: { name: 'Energy', ideology: 'Economy' } },
            { name: 'Flexible Thinker', cost: 3, desc: 'Unfavoured proficiencies cost 4 XP instead of 5.', effect: 'unfavouredDiscount', effectDesc: 'Unfavoured proficiency cost: 4 XP' },
            { name: 'Hydroponics Bay', cost: 3, desc: 'Gain Nutrients Proficiency (2 nutrients/session).', grantsProficiency: { name: 'Nutrients', ideology: 'Green' } },
            { name: 'Ideologist', cost: 2, desc: 'Gain second Belief AND second Aversion.', effect: 'ideology', effectDesc: '+1 Belief, +1 Aversion' },
            { name: 'I Know A Guy', cost: 3, desc: 'Once per downtime, suggest helpful NPC to Refs.' },
            { name: 'Low Profile', cost: 4, desc: 'Damage assigned last in battle.', excludes: ['Bullet Magnet'] },
            { name: 'Meticulous', cost: 5, desc: 'Once per session, redraw a skill card.' },
            { name: 'Notable', cost: 3, desc: 'Gain reputation level with faction sub-group.' },
            { name: 'One With Nature', cost: 2, desc: 'Less likely to disturb native life.' },
            { name: 'Practiced', cost: 1, desc: 'Buy extra card for existing Proficiency.', multiple: true },
            { name: 'Resolute', cost: 5, desc: 'Must be traumatised twice for Shaken→Toll.' },
            { name: 'Rich Ore Seam', cost: 3, desc: 'Gain Minerals Proficiency (2 minerals/session).', grantsProficiency: { name: 'Minerals', ideology: 'Industry' } },
            { name: 'Rising Star', cost: 3, desc: '+3 rep one sub-group, -1 three others.', creationOnly: true },
            { name: 'Robust', cost: 5, desc: 'Must be damaged twice for injured→dying.' },
            { name: 'Skilled', cost: 2, desc: '+1 free proficiency from favoured ideology.', multiple: true, effect: 'proficiency', effectDesc: '+1 free proficiency per purchase' },
            { name: 'Spark of Genius', cost: 3, desc: 'Random Breakthrough each session start.' },
            { name: 'Unity Pod', cost: 1, desc: 'Small starting resources.', creationOnly: true },
            { name: 'Versatile', cost: 5, desc: 'One free proficiency from any ideology (including aversion).', creationOnly: true, effect: 'proficiency', effectDesc: 'Select one free proficiency from any ideology' },
            { name: 'Whispers', cost: 5, desc: 'Hear whispers in dreams. Sometimes learn things.' }
        ];
        
        const DRAWBACKS = [
            { name: 'Addicted', cost: 1, desc: '1 energy each downtime or gain Stress.' },
            { name: 'Agoraphobic', cost: 1, desc: '+0 cards count as -2 outside bases.' },
            { name: 'Besmirched', cost: 1, desc: '-1 reputation with faction sub-group.' },
            { name: 'Bullet Magnet', cost: 3, desc: 'Damage assigned first in combat.', excludes: ['Low Profile'] },
            { name: 'Clumsy', cost: 5, desc: 'Failed checks automatically botch.' },
            { name: 'Dark Secret', cost: 3, desc: 'Terrible past - execution/exile if discovered.', creationOnly: true },
            { name: 'Dedicated', cost: 1, desc: 'Must follow superior orders or Stress.', excludeFactions: ['hive'] },
            { name: 'Dull', cost: 1, desc: 'Difficulty gaining reputation.' },
            { name: 'Easily Bored', cost: 3, desc: 'Duplicate proficiencies cost +1 XP each.', effect: 'duplicateCost', effectDesc: 'Duplicates cost +1 XP' },
            { name: 'Faction Rebel', cost: 1, desc: 'Faction ideology doesn\'t match core.', variableCost: { hive: 2 } },
            { name: 'Fragile', cost: 4, desc: 'One fewer health - injured→bleeding out.' },
            { name: 'Ideologue', cost: 2, desc: '+1 Aversion, must act against it or Stress.', effect: 'ideology', effectDesc: '+1 Aversion' },
            { name: 'Indebted', cost: 4, desc: 'No income, must pay interest.', excludeFactions: ['hive'] },
            { name: 'Infamous', cost: 3, desc: 'Negative rep with unfamiliar factions.' },
            { name: 'In Hiding', cost: 2, desc: 'Using fake identity.', excludes: ['Nemesis', 'Celebrity'] },
            { name: 'Ire of the Leader', cost: 3, desc: 'High-ranking individual dislikes you. -2 rep.' },
            { name: 'Manchurian Candidate', cost: 4, desc: 'Psychological conditioning. Requires Ref agreement.' },
            { name: 'Micromanager', cost: 2, desc: 'Stress if others build in your base.', prereqNote: 'Requires Base Commander advantage', prereqCheck: (s) => s.advantages.includes('Base Commander') },
            { name: 'Nemesis', cost: 2, desc: 'Powerful individual hunting you.', excludes: ['In Hiding', 'Datalink Files Deleted'] },
            { name: 'Offensive to Nature', cost: 2, desc: 'Attracts hostile native life.' },
            { name: 'Overconfident', cost: 2, desc: 'Stress when failing skilled checks.' },
            { name: 'Past Trauma', cost: 2, desc: 'Start with a Toll.' },
            { name: 'Scrambled DNA', cost: 3, desc: 'Cloning doesn\'t work - death permanent.' },
            { name: 'Sloppy', cost: 5, desc: 'Refs may force recheck without positive card.' },
            { name: 'Tunnel Vision', cost: 2, desc: 'All non-favoured ideologies count as Aversions.', effect: 'proficiency', effectDesc: 'Can only learn from favoured ideologies' },
            { name: 'Unlucky', cost: 4, desc: 'Refs may add sabotage card.' },
            { name: 'Unskilled', cost: 2, desc: '-1 starting proficiency.', creationOnly: true, effect: 'proficiency', effectDesc: '-1 proficiency slot' },
            { name: 'Weak-Willed', cost: 4, desc: 'Trauma immediately gives Toll.', excludeFactions: ['believers'] }
        ];
        
        // Items requiring additional choices
        const REQUIRES_CHOICE = {
            proficiencies: {
                'Ally': { type: 'ideology', label: 'Ally\'s Ideology', desc: 'Which ideology does your ally support?' },
                'Community': { type: 'ideology', label: 'Community\'s Ideology', desc: 'Which ideology does your community support?' },
                'Follower': { type: 'ideology', label: 'Followers\' Ideology', desc: 'Which ideology do your followers support?' },
                'Contact': { type: 'text', label: 'Contact\'s Specialty', desc: 'Describe your contact\'s area of expertise' }
            },
            advantages: {
                'Practiced': { type: 'proficiency', label: 'Enhanced Proficiency', desc: 'Select which proficiency gets an extra card', multiple: true },
                'Notable': { type: 'text', label: 'Favored Sub-group', desc: 'Which sub-group do you have reputation with?', multiple: true },
                'Rising Star': { type: 'risingstar', label: 'Reputation Distribution', desc: 'Specify favored sub-group (+3) and three penalized (-1 each)' },
                'Earth Artifact': { type: 'text', label: 'Artifact Description', desc: 'Describe your Earth artifact' },
                'Unity Pod': { type: 'text', label: 'Pod Contents', desc: 'Describe your starting resources' },
                'Versatile': { type: 'versatile', label: 'Free Proficiency', desc: 'Select one free proficiency from any ideology' },
                'Earthling': { type: 'earthling', label: 'Earthling Choices', desc: 'Select two free proficiencies from favoured ideologies, a sub-group for reputation, and describe your toll' },
                'Skilled': { type: 'skilled', label: 'Free Proficiency', desc: 'Select one free proficiency from a favoured ideology', multiple: true }
            },
            drawbacks: {
                'Besmirched': { type: 'text', label: 'Penalized Sub-group', desc: 'Which sub-group do you have negative reputation with?', multiple: true },
                'Addicted': { type: 'text', label: 'Addiction', desc: 'What are you addicted to?', multiple: true },
                'Nemesis': { type: 'text', label: 'Nemesis Description', desc: 'Describe the individual hunting you' },
                'Ire of the Leader': { type: 'text', label: 'Leader Description', desc: 'Which high-ranking individual dislikes you?' },
                'Dark Secret': { type: 'text', label: 'Secret Description', desc: 'What is your dark secret?' },
                'Past Trauma': { type: 'text', label: 'Trauma/Toll', desc: 'What is your starting toll?', multiple: true },
                'Manchurian Candidate': { type: 'text', label: 'Conditioning', desc: 'Describe the psychological conditioning/trigger' }
            }
        };
        
        // State
        let state = {
            name: '',
            concept: '',
            faction: '',
            factionIdeology: '',
            roleIdeology: '',
            beliefIdeology: '',
            aversionIdeology: '',
            secondBeliefIdeology: '',
            secondAversionIdeology: '',
            proficiencies: [],
            advantages: [],
            drawbacks: [],
            currentProfTab: null,
            spartanChoice: null, // Track Spartan's weapon/armor choice
            // Choices for items requiring additional selection
            proficiencyChoices: {}, // { 'Ally|Decentralisation': { ideology: 'Economy' }, ... }
            advantageChoices: {}, // { 'Practiced': [{ proficiency: 'Exterminate' }], 'Notable': { subgroup: 'Command Staff' }, ... }
            drawbackChoices: {} // { 'Besmirched': { subgroup: 'Board of Directors' }, ... }
        };
        
        // Helper Functions
        
        // Choice management functions
        function getProficiencyChoiceKey(name, ideology) {
            return `${name}|${ideology}`;
        }
        
        // For proficiencies with multiple instances (Ally, Follower, etc.), choices are stored as arrays
        function getProficiencyChoice(name, ideology, index = 0) {
            const key = getProficiencyChoiceKey(name, ideology);
            const stored = state.proficiencyChoices[key];
            if (Array.isArray(stored)) {
                return stored[index] || null;
            }
            // Legacy single choice format - return for index 0
            return index === 0 ? stored : null;
        }
        
        function getProficiencyChoices(name, ideology) {
            const key = getProficiencyChoiceKey(name, ideology);
            const stored = state.proficiencyChoices[key];
            if (Array.isArray(stored)) {
                return stored;
            }
            // Legacy single choice format - convert to array
            return stored ? [stored] : [];
        }
        
        function setProficiencyChoice(name, ideology, choice, index = 0) {
            const key = getProficiencyChoiceKey(name, ideology);
            let stored = state.proficiencyChoices[key];
            
            // Convert to array format if needed
            if (!Array.isArray(stored)) {
                stored = stored ? [stored] : [];
            }
            
            // Ensure array is big enough
            while (stored.length <= index) {
                stored.push(null);
            }
            
            stored[index] = choice;
            state.proficiencyChoices[key] = stored;
            validate();
        }
        
        function removeProficiencyChoiceAtIndex(name, ideology, index) {
            const key = getProficiencyChoiceKey(name, ideology);
            let stored = state.proficiencyChoices[key];
            
            if (Array.isArray(stored) && index < stored.length) {
                stored.splice(index, 1);
                if (stored.length === 0) {
                    delete state.proficiencyChoices[key];
                } else {
                    state.proficiencyChoices[key] = stored;
                }
            }
        }
        
        function getAdvantageChoice(name) {
            return state.advantageChoices[name] || null;
        }
        
        function setAdvantageChoice(name, choice) {
            state.advantageChoices[name] = choice;
            validate();
        }
        
        function getDrawbackChoice(name) {
            return state.drawbackChoices[name] || null;
        }
        
        function setDrawbackChoice(name, choice) {
            state.drawbackChoices[name] = choice;
            validate();
        }
        
        function renderPracticedChoices() {
            const practicedCount = state.advantages.filter(a => a === 'Practiced').length;
            const choices = state.advantageChoices['Practiced'] || [];
            
            // Ensure choices array matches count
            while (choices.length < practicedCount) {
                choices.push({ proficiency: '', ideology: '' });
            }
            while (choices.length > practicedCount) {
                choices.pop();
            }
            state.advantageChoices['Practiced'] = choices;
            
            // Get unique proficiencies (name + ideology combination)
            const uniqueProfs = [];
            const seen = new Set();
            state.proficiencies.forEach(p => {
                const key = `${p.name}|${p.ideology}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueProfs.push(p);
                }
            });
            
            let html = '<div class="practiced-list">';
            for (let i = 0; i < practicedCount; i++) {
                const currentKey = choices[i]?.proficiency ? `${choices[i].proficiency}|${choices[i].ideology}` : '';
                html += `<div class="practiced-item">
                    <span>#${i + 1}:</span>
                    <select onchange="updatePracticedChoice(${i}, this.value)">
                        <option value="">-- Select Proficiency --</option>`;
                uniqueProfs.forEach(p => {
                    const key = `${p.name}|${p.ideology}`;
                    const selected = currentKey === key ? 'selected' : '';
                    html += `<option value="${key}" ${selected}>${p.name} (${p.ideology.substring(0,3)})</option>`;
                });
                html += `</select></div>`;
            }
            html += '</div>';
            return html;
        }
        
        function renderVersatileChoices() {
            const currentChoice = getAdvantageChoice('Versatile');
            const currentKey = currentChoice ? `${currentChoice.proficiency}|${currentChoice.ideology}` : '';
            
            let html = `<select onchange="updateVersatileChoice(this.value)" onclick="event.stopPropagation()">
                <option value="">-- Select Free Proficiency --</option>`;
            
            // Group proficiencies by ideology
            IDEOLOGIES.forEach(ideology => {
                const profs = PROFICIENCIES[ideology];
                html += `<optgroup label="${ideology}">`;
                Object.keys(profs).forEach(profName => {
                    const key = `${profName}|${ideology}`;
                    const selected = currentKey === key ? 'selected' : '';
                    html += `<option value="${key}" ${selected}>${profName}</option>`;
                });
                html += `</optgroup>`;
            });
            
            html += `</select>`;
            
            // Show selected proficiency info
            if (currentChoice && currentChoice.proficiency) {
                const profDesc = PROFICIENCIES[currentChoice.ideology]?.[currentChoice.proficiency] || '';
                html += `<div class="versatile-selected" style="margin-top: 8px; padding: 8px; background: var(--bg-input); border-radius: 4px;">
                    <strong>${currentChoice.proficiency}</strong> <small>(${currentChoice.ideology})</small>
                    <div style="font-size: 0.85em; color: var(--text-dim);">${profDesc}</div>
                </div>`;
            }
            
            return html;
        }
        
        function updateVersatileChoice(value) {
            if (!value) {
                // Clear the choice and remove the proficiency
                const oldChoice = getAdvantageChoice('Versatile');
                if (oldChoice && oldChoice.proficiency) {
                    // Remove the old proficiency from state
                    const idx = state.proficiencies.findIndex(p => 
                        p.name === oldChoice.proficiency && p.ideology === oldChoice.ideology
                    );
                    if (idx >= 0) state.proficiencies.splice(idx, 1);
                }
                state.advantageChoices['Versatile'] = null;
            } else {
                const [profName, ideology] = value.split('|');
                const oldChoice = getAdvantageChoice('Versatile');
                
                // Remove old proficiency if different
                if (oldChoice && oldChoice.proficiency && 
                    (oldChoice.proficiency !== profName || oldChoice.ideology !== ideology)) {
                    const idx = state.proficiencies.findIndex(p => 
                        p.name === oldChoice.proficiency && p.ideology === oldChoice.ideology
                    );
                    if (idx >= 0) state.proficiencies.splice(idx, 1);
                }
                
                // Add new proficiency if not already present
                const exists = state.proficiencies.some(p => p.name === profName && p.ideology === ideology);
                if (!exists) {
                    state.proficiencies.push({ name: profName, ideology });
                }
                
                state.advantageChoices['Versatile'] = { proficiency: profName, ideology };
            }
            
            updateXP();
            updateProficiencyTabs(true);
            renderAdvantages(true);
            validate();
        }
        
        function renderEarthlingChoices() {
            const choice = state.advantageChoices['Earthling'] || { 
                proficiencies: [{ name: '', ideology: '' }, { name: '', ideology: '' }], 
                subgroup: '', 
                toll: '' 
            };
            // Ensure proficiencies array exists with correct structure
            if (!choice.proficiencies) {
                choice.proficiencies = [{ name: '', ideology: '' }, { name: '', ideology: '' }];
            }
            
            const favoured = getFavouredIdeologies();
            
            let html = '<div class="earthling-choices">';
            
            // Two proficiency selections from favoured ideologies
            for (let i = 0; i < 2; i++) {
                const currentProf = choice.proficiencies[i] || { name: '', ideology: '' };
                const currentKey = currentProf.name ? `${currentProf.name}|${currentProf.ideology}` : '';
                
                html += `<div class="choice-row" style="margin-bottom: 8px;">
                    <label>Free Proficiency #${i + 1}:</label>
                    <select onchange="updateEarthlingProficiency(${i}, this.value)" onclick="event.stopPropagation()">
                        <option value="">-- Select Proficiency --</option>`;
                
                // Group proficiencies by favoured ideology
                favoured.forEach(ideology => {
                    const profs = PROFICIENCIES[ideology];
                    if (profs) {
                        html += `<optgroup label="${ideology}">`;
                        Object.keys(profs).forEach(profName => {
                            const key = `${profName}|${ideology}`;
                            const selected = currentKey === key ? 'selected' : '';
                            html += `<option value="${key}" ${selected}>${profName}</option>`;
                        });
                        html += `</optgroup>`;
                    }
                });
                
                html += `</select>`;
                
                // Show selected proficiency description
                if (currentProf.name && currentProf.ideology) {
                    const desc = PROFICIENCIES[currentProf.ideology]?.[currentProf.name] || '';
                    html += `<div class="choice-desc" style="margin-top: 4px; font-size: 0.85em; color: var(--text-dim);">${currentProf.name} (${currentProf.ideology}): ${desc}</div>`;
                }
                
                html += `</div>`;
            }
            
            // Sub-group for reputation
            html += `<div class="choice-row" style="margin-bottom: 8px;">
                <label>+1 Rep Sub-group:</label>
                <input type="text" value="${(choice.subgroup || '').replace(/"/g, '&quot;')}" 
                    placeholder="Sub-group name"
                    onchange="updateEarthlingChoice('subgroup', this.value)"
                    onclick="event.stopPropagation()">
            </div>`;
            
            // Toll description
            html += `<div class="choice-row">
                <label>Starting Toll:</label>
                <input type="text" value="${(choice.toll || '').replace(/"/g, '&quot;')}" 
                    placeholder="Describe your toll"
                    onchange="updateEarthlingChoice('toll', this.value)"
                    onclick="event.stopPropagation()">
            </div>`;
            
            html += '</div>';
            return html;
        }
        
        function updateEarthlingProficiency(index, value) {
            if (!state.advantageChoices['Earthling']) {
                state.advantageChoices['Earthling'] = { 
                    proficiencies: [{ name: '', ideology: '' }, { name: '', ideology: '' }], 
                    subgroup: '', 
                    toll: '' 
                };
            }
            const choice = state.advantageChoices['Earthling'];
            if (!choice.proficiencies) {
                choice.proficiencies = [{ name: '', ideology: '' }, { name: '', ideology: '' }];
            }
            
            // Remove old proficiency from state if changing
            const oldProf = choice.proficiencies[index];
            if (oldProf && oldProf.name && oldProf.ideology) {
                const idx = state.proficiencies.findIndex(p => 
                    p.name === oldProf.name && p.ideology === oldProf.ideology
                );
                if (idx >= 0) {
                    state.proficiencies.splice(idx, 1);
                }
            }
            
            // Parse new value and add to state
            if (value) {
                const [profName, ideology] = value.split('|');
                choice.proficiencies[index] = { name: profName, ideology };
                state.proficiencies.push({ name: profName, ideology });
            } else {
                choice.proficiencies[index] = { name: '', ideology: '' };
            }
            
            updateXP();
            updateProficiencyTabs(true);
            renderAdvantages(true);
            validate();
        }
        
        function updateEarthlingChoice(field, value) {
            if (!state.advantageChoices['Earthling']) {
                state.advantageChoices['Earthling'] = { 
                    proficiencies: [{ name: '', ideology: '' }, { name: '', ideology: '' }], 
                    subgroup: '', 
                    toll: '' 
                };
            }
            const choice = state.advantageChoices['Earthling'];
            
            if (field === 'subgroup') {
                choice.subgroup = value;
            } else if (field === 'toll') {
                choice.toll = value;
            }
            
            renderAdvantages(true);
            validate();
        }
        
        function renderSkilledChoices(count) {
            // Skilled grants proficiencies - one dropdown per instance
            const choices = state.advantageChoices['Skilled'] || [];
            // Ensure choices array matches count
            while (choices.length < count) {
                choices.push({ name: '', ideology: '' });
            }
            while (choices.length > count) {
                // Remove proficiency when reducing count
                const removed = choices.pop();
                if (removed && removed.name && removed.ideology) {
                    const idx = state.proficiencies.findIndex(p => 
                        p.name === removed.name && p.ideology === removed.ideology
                    );
                    if (idx >= 0) {
                        state.proficiencies.splice(idx, 1);
                    }
                }
            }
            state.advantageChoices['Skilled'] = choices;
            
            const favoured = getFavouredIdeologies();
            
            let html = '<div class="skilled-choices">';
            for (let i = 0; i < count; i++) {
                const currentProf = choices[i] || { name: '', ideology: '' };
                const currentKey = currentProf.name ? `${currentProf.name}|${currentProf.ideology}` : '';
                
                html += `<div class="choice-row" style="margin-bottom: 8px;">
                    <label>Proficiency #${i + 1}:</label>
                    <select onchange="updateSkilledProficiency(${i}, this.value)" onclick="event.stopPropagation()">
                        <option value="">-- Select Proficiency --</option>`;
                
                // Group proficiencies by favoured ideology
                favoured.forEach(ideology => {
                    const profs = PROFICIENCIES[ideology];
                    if (profs) {
                        html += `<optgroup label="${ideology}">`;
                        Object.keys(profs).forEach(profName => {
                            const key = `${profName}|${ideology}`;
                            const selected = currentKey === key ? 'selected' : '';
                            html += `<option value="${key}" ${selected}>${profName}</option>`;
                        });
                        html += `</optgroup>`;
                    }
                });
                
                html += `</select>`;
                
                // Show selected proficiency description
                if (currentProf.name && currentProf.ideology) {
                    const desc = PROFICIENCIES[currentProf.ideology]?.[currentProf.name] || '';
                    html += `<div class="choice-desc" style="margin-top: 4px; font-size: 0.85em; color: var(--text-dim);">${currentProf.name} (${currentProf.ideology}): ${desc}</div>`;
                }
                
                html += `</div>`;
            }
            html += '</div>';
            return html;
        }
        
        function updateSkilledProficiency(index, value) {
            if (!state.advantageChoices['Skilled']) {
                state.advantageChoices['Skilled'] = [];
            }
            const choices = state.advantageChoices['Skilled'];
            
            // Remove old proficiency from state if changing
            const oldProf = choices[index];
            if (oldProf && oldProf.name && oldProf.ideology) {
                const idx = state.proficiencies.findIndex(p => 
                    p.name === oldProf.name && p.ideology === oldProf.ideology
                );
                if (idx >= 0) {
                    state.proficiencies.splice(idx, 1);
                }
            }
            
            // Parse new value and add to state
            if (value) {
                const [profName, ideology] = value.split('|');
                choices[index] = { name: profName, ideology };
                state.proficiencies.push({ name: profName, ideology });
            } else {
                choices[index] = { name: '', ideology: '' };
            }
            
            updateXP();
            updateProficiencyTabs(true);
            renderAdvantages(true);
            validate();
        }
        
        function renderMultipleAdvantageChoices(advName, count) {
            const config = REQUIRES_CHOICE.advantages[advName];
            const choices = state.advantageChoices[advName] || [];
            
            // Ensure choices array matches count
            while (choices.length < count) {
                choices.push({ text: '' });
            }
            while (choices.length > count) {
                choices.pop();
            }
            state.advantageChoices[advName] = choices;
            
            let html = '<div class="practiced-list">';
            for (let i = 0; i < count; i++) {
                const currentValue = (choices[i]?.text || '').replace(/"/g, '&quot;');
                html += `<div class="practiced-item">
                    <span>#${i + 1}:</span>
                    <input type="text" value="${currentValue}" 
                        placeholder="${config.desc}"
                        onchange="updateMultipleAdvantageChoice('${advName}', ${i}, this.value)"
                        onclick="event.stopPropagation()">
                </div>`;
            }
            html += '</div>';
            return html;
        }
        
        function updateMultipleAdvantageChoice(advName, index, value) {
            if (!state.advantageChoices[advName]) {
                state.advantageChoices[advName] = [];
            }
            state.advantageChoices[advName][index] = { text: value };
            renderAdvantages();
            validate();
        }
        
        function renderMultipleDrawbackChoices(drawName, count) {
            const config = REQUIRES_CHOICE.drawbacks[drawName];
            const choices = state.drawbackChoices[drawName] || [];
            
            // Ensure choices array matches count
            while (choices.length < count) {
                choices.push({ text: '' });
            }
            while (choices.length > count) {
                choices.pop();
            }
            state.drawbackChoices[drawName] = choices;
            
            let html = '<div class="practiced-list">';
            for (let i = 0; i < count; i++) {
                const currentValue = (choices[i]?.text || '').replace(/"/g, '&quot;');
                html += `<div class="practiced-item">
                    <span>#${i + 1}:</span>
                    <input type="text" value="${currentValue}" 
                        placeholder="${config.desc}"
                        onchange="updateMultipleDrawbackChoice('${drawName}', ${i}, this.value)"
                        onclick="event.stopPropagation()">
                </div>`;
            }
            html += '</div>';
            return html;
        }
        
        function updateMultipleDrawbackChoice(drawName, index, value) {
            if (!state.drawbackChoices[drawName]) {
                state.drawbackChoices[drawName] = [];
            }
            state.drawbackChoices[drawName][index] = { text: value };
            renderDrawbacks();
            validate();
        }
        
        function updatePracticedChoice(index, value) {
            if (!state.advantageChoices['Practiced']) {
                state.advantageChoices['Practiced'] = [];
            }
            if (value) {
                const [proficiency, ideology] = value.split('|');
                state.advantageChoices['Practiced'][index] = { proficiency, ideology };
            } else {
                state.advantageChoices['Practiced'][index] = { proficiency: '', ideology: '' };
            }
            renderAdvantages();
            validate();
        }
        
        function renderRisingStarChoices() {
            const choice = state.advantageChoices['Rising Star'] || { favored: '', penalized: ['', '', ''] };
            
            let html = '<div class="rising-star-choices">';
            
            // Favored (+3)
            html += `<div class="choice-row">
                <label style="color: var(--success);">+3 Rep:</label>
                <input type="text" value="${(choice.favored || '').replace(/"/g, '&quot;')}" 
                    placeholder="Sub-group name"
                    onchange="updateRisingStarFavored(this.value)"
                    onclick="event.stopPropagation()">
            </div>`;
            
            // Penalized (-1 each)
            for (let i = 0; i < 3; i++) {
                html += `<div class="choice-row">
                    <label style="color: var(--error);">-1 Rep #${i+1}:</label>
                    <input type="text" value="${(choice.penalized[i] || '').replace(/"/g, '&quot;')}" 
                        placeholder="Sub-group name"
                        onchange="updateRisingStarPenalized(${i}, this.value)"
                        onclick="event.stopPropagation()">
                </div>`;
            }
            
            html += '</div>';
            return html;
        }
        
        function updateRisingStarFavored(value) {
            if (!state.advantageChoices['Rising Star']) {
                state.advantageChoices['Rising Star'] = { favored: '', penalized: ['', '', ''] };
            }
            state.advantageChoices['Rising Star'].favored = value;
            renderAdvantages();
            validate();
        }
        
        function updateRisingStarPenalized(index, value) {
            if (!state.advantageChoices['Rising Star']) {
                state.advantageChoices['Rising Star'] = { favored: '', penalized: ['', '', ''] };
            }
            state.advantageChoices['Rising Star'].penalized[index] = value;
            renderAdvantages();
            validate();
        }
        
        function handleProficiencyChoiceChange(profName, ideology, value, index = 0) {
            setProficiencyChoice(profName, ideology, { value: value }, index);
            updateProficiencyTabs();
        }
        
        function handleAdvantageChoiceChange(advName, value, field = 'subgroup') {
            const current = getAdvantageChoice(advName) || {};
            current[field] = value;
            setAdvantageChoice(advName, current);
            renderAdvantages();
        }
        
        function handleDrawbackChoiceChange(drawName, value, field = 'subgroup') {
            const current = getDrawbackChoice(drawName) || {};
            current[field] = value;
            setDrawbackChoice(drawName, current);
            renderDrawbacks();
        }
        
        function isChoiceComplete(itemType, name, ideology = null) {
            const config = REQUIRES_CHOICE[itemType]?.[name];
            if (!config) return true; // No choice required
            
            if (itemType === 'proficiencies') {
                // Get count of this proficiency
                const profCount = state.proficiencies.filter(p => p.name === name && p.ideology === ideology).length;
                const choices = getProficiencyChoices(name, ideology);
                
                // All instances must have choices filled
                for (let i = 0; i < profCount; i++) {
                    const choice = choices[i];
                    if (config.type === 'text') {
                        if (!choice || !choice.value || choice.value.trim() === '') return false;
                    } else if (config.type === 'ideology') {
                        if (!choice || !choice.value) return false;
                    }
                }
                return true;
            } else if (itemType === 'advantages') {
                const choice = getAdvantageChoice(name);
                const count = state.advantages.filter(a => a === name).length;
                
                if (name === 'Practiced') {
                    return choice && choice.length === count && choice.every(c => c.proficiency);
                }
                if (name === 'Rising Star') {
                    return choice && choice.favored && choice.favored.trim() !== '' && 
                           choice.penalized.filter(p => p && p.trim() !== '').length === 3;
                }
                if (name === 'Versatile') {
                    return choice && choice.proficiency && choice.ideology;
                }
                if (name === 'Earthling') {
                    return choice && 
                           choice.proficiencies?.filter(p => p && p.name && p.ideology).length === 2 &&
                           choice.subgroup && choice.subgroup.trim() !== '' &&
                           choice.toll && choice.toll.trim() !== '';
                }
                if (name === 'Skilled') {
                    return choice && Array.isArray(choice) && choice.length === count &&
                           choice.every(c => c && c.name && c.ideology);
                }
                if (config.type === 'text' && config.multiple && count > 1) {
                    return choice && Array.isArray(choice) && choice.length === count && 
                           choice.every(c => c.text && c.text.trim() !== '');
                }
                if (config.type === 'text') {
                    return choice && choice.text && choice.text.trim() !== '';
                }
            } else if (itemType === 'drawbacks') {
                const choice = getDrawbackChoice(name);
                const count = state.drawbacks.filter(d => d === name).length;
                
                if (config.type === 'text' && config.multiple && count > 1) {
                    return choice && Array.isArray(choice) && choice.length === count && 
                           choice.every(c => c.text && c.text.trim() !== '');
                }
                if (config.type === 'text') {
                    return choice && choice.text && choice.text.trim() !== '';
                }
            }
            return true;
        }
        
        function getFactionBonusProficiencies() {
            if (!state.faction) return [];
            const faction = FACTIONS[state.faction];
            let bonuses = [...(faction.bonusProficiencies || [])];
            
            // Add Spartan choice if selected
            if (state.faction === 'spartans' && state.spartanChoice) {
                bonuses.push(state.spartanChoice);
            }
            
            return bonuses;
        }
        
        function getFactionBonusAdvantages() {
            if (!state.faction) return [];
            const faction = FACTIONS[state.faction];
            return faction.bonusAdvantages || [];
        }
        
        function isBonusProficiency(name, ideology) {
            const bonuses = getFactionBonusProficiencies();
            return bonuses.some(b => b.name === name && b.ideology === ideology);
        }
        
        function isBonusAdvantage(name) {
            return getFactionBonusAdvantages().includes(name);
        }
        
        function getFavouredIdeologies() {
            const ideologies = new Set();
            if (state.factionIdeology) ideologies.add(state.factionIdeology);
            if (state.roleIdeology) ideologies.add(state.roleIdeology);
            if (state.beliefIdeology) ideologies.add(state.beliefIdeology);
            if (state.secondBeliefIdeology) ideologies.add(state.secondBeliefIdeology);
            return Array.from(ideologies);
        }
        
        function getAversionIdeologies() {
            const aversions = new Set();
            if (state.aversionIdeology) aversions.add(state.aversionIdeology);
            if (state.secondAversionIdeology) aversions.add(state.secondAversionIdeology);
            return Array.from(aversions);
        }
        
        function getMaxProficiencies() {
            // Now returns effectively unlimited - we track via XP cost instead
            // But we still show a "base" number for display purposes
            return getBaseProficiencySlots() + 100; // Allow plenty of extra purchases
        }
        
        function getMaxProficienciesBase() {
            // Base is always 6 free slots
            let max = 6;
            // Unskilled: -1 slot
            if (state.drawbacks.includes('Unskilled')) max -= 1;
            return max;
        }
        
        // Get base proficiency slots (free slots from faction + advantages)
        function getBaseProficiencySlots() {
            return getMaxProficienciesBase();
        }
        
        // Calculate XP cost for extra proficiencies beyond base slots
        function getExtraProficiencyXPCost() {
            const baseSlots = getBaseProficiencySlots();
            const bonusProfs = getFactionBonusProficiencies();
            const favoured = getFavouredIdeologies();
            const hasVersatile = state.advantages.includes('Versatile');
            const versatileChoice = hasVersatile ? getAdvantageChoice('Versatile') : null;
            const hasEasilyBored = state.drawbacks.includes('Easily Bored');
            const hasFlexibleThinker = state.advantages.includes('Flexible Thinker');
            
            // Build map of all granted proficiencies (these are free)
            const grantedProfs = new Map(); // Map of key -> count
            
            // Faction bonus proficiencies
            bonusProfs.forEach(bp => {
                const key = `${bp.name}|${bp.ideology}`;
                grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
            });
            
            // Advantages with grantsProficiency property
            ADVANTAGES.forEach(adv => {
                if (adv.grantsProficiency && state.advantages.includes(adv.name)) {
                    const key = `${adv.grantsProficiency.name}|${adv.grantsProficiency.ideology}`;
                    grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
                }
            });
            
            // Earthling granted proficiencies
            if (state.advantages.includes('Earthling')) {
                const earthlingChoice = getAdvantageChoice('Earthling');
                if (earthlingChoice?.proficiencies) {
                    earthlingChoice.proficiencies.forEach(p => {
                        if (p && p.name && p.ideology) {
                            const key = `${p.name}|${p.ideology}`;
                            grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
                        }
                    });
                }
            }
            
            // Skilled granted proficiencies
            if (state.advantages.includes('Skilled')) {
                const skilledChoices = state.advantageChoices['Skilled'] || [];
                skilledChoices.forEach(p => {
                    if (p && p.name && p.ideology) {
                        const key = `${p.name}|${p.ideology}`;
                        grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
                    }
                });
            }
            
            // Versatile free proficiency
            if (versatileChoice && versatileChoice.proficiency && versatileChoice.ideology) {
                const key = `${versatileChoice.proficiency}|${versatileChoice.ideology}`;
                grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
            }
            
            // Track proficiency counts for duplicate detection
            const profCounts = {};
            state.proficiencies.forEach(p => {
                const key = `${p.name}|${p.ideology}`;
                profCounts[key] = (profCounts[key] || 0) + 1;
            });
            
            // Determine which proficiencies cost XP
            const xpProfs = [];
            const grantedUsed = {};
            const processedCounts = {};
            
            state.proficiencies.forEach(p => {
                const key = `${p.name}|${p.ideology}`;
                processedCounts[key] = (processedCounts[key] || 0) + 1;
                const instanceNum = processedCounts[key];
                
                // Check if this is a granted proficiency (free)
                const grantedCount = grantedProfs.get(key) || 0;
                const usedGranted = grantedUsed[key] || 0;
                if (usedGranted < grantedCount) {
                    grantedUsed[key] = usedGranted + 1;
                    return; // Free
                }
                
                // This one costs XP
                const isDuplicate = profCounts[key] > 1 && instanceNum > 1;
                xpProfs.push({ ...p, key, isDuplicate });
            });
            
            // Calculate costs
            let totalCost = 0;
            const unfavouredCostPer = hasFlexibleThinker ? 4 : 5;
            const freeSlots = baseSlots; // Always 6 (or 5 with Unskilled)
            let favouredUsed = 0;
            
            xpProfs.forEach(p => {
                const isFavoured = favoured.includes(p.ideology);
                let cost = 0;
                
                if (!isFavoured) {
                    // Unfavoured always costs XP
                    cost = unfavouredCostPer;
                } else {
                    // Favoured: free slots first, then 2 XP each
                    if (favouredUsed < freeSlots) {
                        favouredUsed++;
                        cost = 0; // Free slot
                    } else {
                        cost = 2; // Extra favoured costs 2 XP
                    }
                }
                
                // Easily Bored: +1 XP for duplicates that cost XP
                if (hasEasilyBored && p.isDuplicate && cost > 0) {
                    cost += 1;
                }
                
                totalCost += cost;
            });
            
            return totalCost;
        }
        
        // Get max proficiency XP (7 normally, 9 for Peacekeepers) - kept for reference
        function getMaxProficiencyXP() {
            return state.faction === 'peacekeepers' ? 9 : 7;
        }
        
        // Calculate current net XP
        function getNetXP() {
            const advXP = getTotalAdvXP();
            const drawXP = getTotalDrawXP();
            const bonusXP = state.faction ? FACTIONS[state.faction].bonusXP : 0;
            const profXP = getExtraProficiencyXPCost();
            return drawXP + bonusXP - advXP - profXP;
        }
        
        // Check if we can afford to add another proficiency from this ideology
        // Net XP cannot go below -7
        function canAffordExtraProficiency(ideology) {
            const currentNetXP = getNetXP();
            const favoured = getFavouredIdeologies();
            const isFavoured = favoured.includes(ideology);
            const hasFlexibleThinker = state.advantages.includes('Flexible Thinker');
            
            // Determine the cost of adding this proficiency
            let addCost = 0;
            if (!isFavoured) {
                // Unfavoured costs 5 XP (or 4 XP with Flexible Thinker)
                addCost = hasFlexibleThinker ? 4 : 5;
            } else {
                // Favoured: check if we have free slots left
                const baseSlots = getBaseProficiencySlots();
                const bonusProfs = getFactionBonusProficiencies();
                const freeSlots = baseSlots - bonusProfs.length;
                
                // Get granted proficiencies (these don't consume slots)
                const grantedProfsMap = new Map();
                ADVANTAGES.forEach(adv => {
                    if (adv.grantsProficiency && state.advantages.includes(adv.name)) {
                        const key = `${adv.grantsProficiency.name}|${adv.grantsProficiency.ideology}`;
                        grantedProfsMap.set(key, (grantedProfsMap.get(key) || 0) + 1);
                    }
                });
                // Add Earthling granted proficiencies
                if (state.advantages.includes('Earthling')) {
                    const earthlingChoice = getAdvantageChoice('Earthling');
                    if (earthlingChoice?.proficiencies) {
                        earthlingChoice.proficiencies.forEach(ep => {
                            if (ep && ep.name && ep.ideology) {
                                const key = `${ep.name}|${ep.ideology}`;
                                grantedProfsMap.set(key, (grantedProfsMap.get(key) || 0) + 1);
                            }
                        });
                    }
                }
                
                // Versatile free proficiency
                const versatileChoice = getAdvantageChoice('Versatile');
                const versatileKey = versatileChoice ? `${versatileChoice.proficiency}|${versatileChoice.ideology}` : null;
                let versatileUsed = false;
                
                // Count current favoured proficiencies that consume slots
                let favouredCount = 0;
                const bonusProfCounts = {};
                const grantedUsedTracker = {};
                
                state.proficiencies.forEach(p => {
                    if (!favoured.includes(p.ideology)) return;
                    const key = `${p.name}|${p.ideology}`;
                    
                    // Check Versatile first
                    if (versatileKey === key && !versatileUsed) {
                        versatileUsed = true;
                        return; // Free, doesn't consume slot
                    }
                    
                    // Check granted
                    const grantedCount = grantedProfsMap.get(key) || 0;
                    const usedGranted = grantedUsedTracker[key] || 0;
                    if (usedGranted < grantedCount) {
                        grantedUsedTracker[key] = usedGranted + 1;
                        return; // Free, doesn't consume slot
                    }
                    
                    // Check bonus
                    if (isBonusProficiency(p.name, p.ideology)) {
                        bonusProfCounts[key] = (bonusProfCounts[key] || 0) + 1;
                        if (bonusProfCounts[key] === 1) {
                            return; // First bonus is free
                        }
                    }
                    
                    favouredCount++;
                });
                
                // If we still have free slots, no cost; otherwise 2 XP
                addCost = favouredCount < freeSlots ? 0 : 2;
            }
            
            // Check if adding this cost would take net XP below -7
            return (currentNetXP - addCost) >= -7;
        }
        
        // Check if an ideology is unfavoured (not faction/role/belief, not aversion)
        function isUnfavouredIdeology(ideology) {
            const favoured = getFavouredIdeologies();
            const aversions = getAversionIdeologies();
            return !favoured.includes(ideology) && !aversions.includes(ideology);
        }
        
        function canLearnFromIdeology(ideology) {
            const favoured = getFavouredIdeologies();
            const aversions = getAversionIdeologies();
            
            // If has Alternative Interpretation, can learn from aversion (but non-favoured)
            const hasAltInterp = state.advantages.includes('Alternative Interpretation');
            
            // If has Tunnel Vision, can ONLY learn from favoured
            const hasTunnelVision = state.drawbacks.includes('Tunnel Vision');
            
            if (hasTunnelVision) {
                return favoured.includes(ideology);
            }
            
            if (aversions.includes(ideology)) {
                return hasAltInterp; // Versatile uses dropdown instead of tabs
            }
            
            return true;
        }
        
        function needsSecondaryIdeologies() {
            return state.advantages.includes('Ideologist') || state.drawbacks.includes('Ideologue');
        }
        
        function needsSecondBelief() {
            return state.advantages.includes('Ideologist');
        }
        
        function needsSecondAversion() {
            return state.advantages.includes('Ideologist') || state.drawbacks.includes('Ideologue');
        }
        
        function clearInvalidProficiencies() {
            const favoured = getFavouredIdeologies();
            const hasVersatile = state.advantages.includes('Versatile');
            const hasAltInterp = state.advantages.includes('Alternative Interpretation');
            const bonusProfs = getFactionBonusProficiencies();
            const versatileChoice = hasVersatile ? getAdvantageChoice('Versatile') : null;
            
            // Filter out proficiencies that are no longer valid (but keep bonus ones and versatile choice)
            state.proficiencies = state.proficiencies.filter(p => {
                // Always keep bonus proficiencies
                if (isBonusProficiency(p.name, p.ideology)) return true;
                
                // Keep the Versatile free proficiency
                if (versatileChoice && p.name === versatileChoice.proficiency && p.ideology === versatileChoice.ideology) {
                    return true;
                }
                
                // If from a favoured ideology, keep it
                if (favoured.includes(p.ideology)) return true;
                
                // If has Alternative Interpretation, check if can still learn from that ideology
                if (hasAltInterp) {
                    return canLearnFromIdeology(p.ideology);
                }
                
                // Otherwise, remove it (unfavoured without special permission)
                return false;
            });
            
            // Clear Versatile choice if Versatile is removed
            if (!hasVersatile && state.advantageChoices['Versatile']) {
                state.advantageChoices['Versatile'] = null;
            }
        }
        
        function updateFactionRebelSelector() {
            const container = document.getElementById('factionRebelSelect');
            const select = document.getElementById('customFactionIdeology');
            const hasFactionRebel = state.drawbacks.includes('Faction Rebel');
            
            container.style.display = hasFactionRebel && state.faction ? 'block' : 'none';
            
            if (!hasFactionRebel || !state.faction) {
                // Reset to default faction ideology
                const faction = state.faction ? FACTIONS[state.faction] : null;
                if (faction && state.factionIdeology !== faction.dominant) {
                    state.factionIdeology = faction.dominant;
                    updateFactionIdeologyDisplay();
                    clearInvalidProficiencies();
                    updateRoleOptions();
                }
                return;
            }
            
            const faction = FACTIONS[state.faction];
            const currentValue = state.factionIdeology;
            
            select.innerHTML = `<option value="${faction.dominant}">${faction.dominant} (Default)</option>`;
            IDEOLOGIES.filter(i => i !== faction.dominant).forEach(ideology => {
                const option = document.createElement('option');
                option.value = ideology;
                option.textContent = ideology;
                if (ideology === currentValue) option.selected = true;
                select.appendChild(option);
            });
            
            // Set selection to current value
            select.value = currentValue;
        }
        
        function updateFactionIdeologyDisplay() {
            const factionIdeologyDiv = document.getElementById('factionIdeology');
            if (state.factionIdeology) {
                const faction = FACTIONS[state.faction];
                const isDefault = state.factionIdeology === faction.dominant;
                const label = isDefault ? '' : ' (Rebel)';
                factionIdeologyDiv.innerHTML = `<span class="ideology-tag dominant">${state.factionIdeology}${label}</span>`;
                showIdeologyDesc('factionIdeologyDesc', state.factionIdeology);
            }
        }
        
        function toggleCollapse(element) {
            element.classList.toggle('collapsed');
            element.nextElementSibling.classList.toggle('collapsed');
        }
        
        function showIdeologyDesc(elementId, ideology, isAversion = false) {
            const el = document.getElementById(elementId);
            if (ideology && IDEOLOGY_DESCRIPTIONS[ideology]) {
                const desc = IDEOLOGY_DESCRIPTIONS[ideology];
                if (isAversion) {
                    el.innerHTML = `
                        <div class="belief-text" style="color: var(--error);">${desc.opposition}</div>
                    `;
                } else {
                    el.innerHTML = `
                        <div class="belief-text">${desc.belief}</div>
                        <div class="opposition-text">Opposition: ${desc.opposition}</div>
                    `;
                }
                el.classList.add('visible');
            } else {
                el.classList.remove('visible');
                el.innerHTML = '';
            }
        }
        
        // Update Functions
        function updateFactionInfo() {
            const factionKey = document.getElementById('faction').value;
            const infoDiv = document.getElementById('factionInfo');
            const bonusInfoDiv = document.getElementById('factionBonusInfo');
            const ideologiesDiv = document.getElementById('factionIdeologies');
            const factionIdeologyDiv = document.getElementById('factionIdeology');
            
            // Clear proficiencies and reset advantages when faction changes
            if (state.faction && state.faction !== factionKey) {
                state.proficiencies = [];
                state.advantages = [];
                state.spartanChoice = null;
            }
            
            if (!factionKey) {
                infoDiv.style.display = 'none';
                bonusInfoDiv.style.display = 'none';
                ideologiesDiv.innerHTML = '';
                factionIdeologyDiv.innerHTML = '<span class="ideology-tag" style="opacity:0.5">Select a faction first</span>';
                showIdeologyDesc('factionIdeologyDesc', null);
                state.faction = '';
                state.factionIdeology = '';
                state.proficiencies = [];
                state.advantages = [];
                state.spartanChoice = null;
                updateRoleOptions();
                renderAdvantages();
                renderDrawbacks();
                return;
            }
            
            const faction = FACTIONS[factionKey];
            state.faction = factionKey;
            state.factionIdeology = faction.dominant;
            
            // Apply faction bonus proficiencies
            applyFactionBonusProficiencies();
            
            // Apply faction bonus advantages
            applyFactionBonusAdvantages();
            
            infoDiv.style.display = 'block';
            infoDiv.innerHTML = `
                <p><strong>Leader:</strong> ${faction.leader}</p>
                <p>${faction.description}</p>
                ${faction.bonusXP > 0 ? `<p style="color: var(--success);">Bonus XP: +${faction.bonusXP}</p>` : ''}
            `;
            
            // Show faction bonus info
            bonusInfoDiv.style.display = 'block';
            let bonusHTML = `<h4>★ Faction Bonuses</h4>`;
            bonusHTML += `<p>${faction.bonusDescription}</p>`;
            
            if (faction.bonusProficiencies && faction.bonusProficiencies.length > 0) {
                faction.bonusProficiencies.forEach(p => {
                    bonusHTML += `<div class="bonus-item">Starting Proficiency: ${p.name} (${p.ideology})</div>`;
                });
            }
            
            if (faction.bonusChoiceProficiencies) {
                bonusHTML += `<div class="bonus-item">Choose: ${faction.bonusChoiceProficiencies.map(p => p.name).join(' OR ')}</div>`;
                bonusHTML += `<div style="margin-top: 8px;">
                    <select id="spartanChoice" onchange="handleSpartanChoice(this.value)" style="width: 100%; padding: 8px; background: var(--bg-dark); border: 1px solid var(--faction-bonus); color: var(--text); border-radius: 4px;">
                        <option value="">-- Select Equipment Proficiency --</option>
                        ${faction.bonusChoiceProficiencies.map(p => `<option value="${p.name}" ${state.spartanChoice && state.spartanChoice.name === p.name ? 'selected' : ''}>${p.name}</option>`).join('')}
                    </select>
                </div>`;
            }
            
            if (faction.bonusAdvantages && faction.bonusAdvantages.length > 0) {
                faction.bonusAdvantages.forEach(a => {
                    const adv = ADVANTAGES.find(x => x.name === a);
                    bonusHTML += `<div class="bonus-item">Starting Advantage: ${a}${adv ? ` (normally ${adv.cost} XP)` : ''}</div>`;
                });
            }
            
            if (faction.startingIncome !== undefined) {
                bonusHTML += `<div class="bonus-item" id="incomeDisplay">Starting Income: ${faction.startingIncome} Energy/session</div>`;
            }
            if (faction.startingUpkeep !== undefined && faction.startingUpkeep > 0) {
                bonusHTML += `<div class="bonus-item">Starting Upkeep: ${faction.startingUpkeep} Energy/session</div>`;
            }
            
            bonusInfoDiv.innerHTML = bonusHTML;
            
            ideologiesDiv.innerHTML = `
                <div class="ideology-row">
                    <span class="ideology-tag dominant">${faction.dominant} (Dominant)</span>
                </div>
                <div class="ideology-row">
                    ${faction.strong.map(i => `<span class="ideology-tag strong">${i} (Strong)</span>`).join('')}
                </div>
                <div class="ideology-row">
                    ${faction.weak.map(i => `<span class="ideology-tag weak">${i} (Weak)</span>`).join('')}
                </div>
            `;
            
            factionIdeologyDiv.innerHTML = `<span class="ideology-tag dominant">${faction.dominant}</span>`;
            showIdeologyDesc('factionIdeologyDesc', faction.dominant);
            
            updateFactionRebelSelector();
            updateRoleOptions();
            renderAdvantages();
            renderDrawbacks();
            updateXP();
        }
        
        function handleSpartanChoice(profName) {
            const faction = FACTIONS[state.faction];
            if (!faction.bonusChoiceProficiencies) return;
            
            // Remove previous choice if any
            if (state.spartanChoice) {
                const idx = state.proficiencies.findIndex(p => 
                    p.name === state.spartanChoice.name && p.ideology === state.spartanChoice.ideology
                );
                if (idx >= 0) {
                    state.proficiencies.splice(idx, 1);
                }
            }
            
            // Add new choice
            if (profName) {
                const choice = faction.bonusChoiceProficiencies.find(p => p.name === profName);
                if (choice) {
                    state.spartanChoice = choice;
                    // Add if not already present
                    if (!state.proficiencies.some(p => p.name === choice.name && p.ideology === choice.ideology)) {
                        state.proficiencies.push({ name: choice.name, ideology: choice.ideology });
                    }
                }
            } else {
                state.spartanChoice = null;
            }
            
            updateProficiencyTabs();
            validate();
        }
        
        function applyFactionBonusProficiencies() {
            const faction = FACTIONS[state.faction];
            if (!faction) return;
            
            // Add mandatory bonus proficiencies
            if (faction.bonusProficiencies) {
                faction.bonusProficiencies.forEach(prof => {
                    if (!state.proficiencies.some(p => p.name === prof.name && p.ideology === prof.ideology)) {
                        state.proficiencies.push({ name: prof.name, ideology: prof.ideology });
                    }
                });
            }
            
            // Re-add spartan choice if it was set
            if (state.spartanChoice) {
                if (!state.proficiencies.some(p => p.name === state.spartanChoice.name && p.ideology === state.spartanChoice.ideology)) {
                    state.proficiencies.push({ name: state.spartanChoice.name, ideology: state.spartanChoice.ideology });
                }
            }
        }
        
        function applyFactionBonusAdvantages() {
            const faction = FACTIONS[state.faction];
            if (!faction || !faction.bonusAdvantages) return;
            
            faction.bonusAdvantages.forEach(advName => {
                if (!state.advantages.includes(advName)) {
                    state.advantages.push(advName);
                }
            });
        }
        
        function updateRoleOptions() {
            const roleSelect = document.getElementById('roleIdeology');
            
            if (!state.faction) {
                roleSelect.disabled = true;
                roleSelect.innerHTML = '<option value="">-- Select faction first --</option>';
                state.roleIdeology = '';
                updateBeliefOptions();
                return;
            }
            
            const faction = FACTIONS[state.faction];
            roleSelect.disabled = false;
            roleSelect.innerHTML = '<option value="">-- Choose Role Ideology --</option>';
            
            IDEOLOGIES.forEach(ideology => {
                if (ideology === state.factionIdeology) return; // Skip current faction ideology
                const isStrong = faction.strong.includes(ideology);
                const option = document.createElement('option');
                option.value = ideology;
                option.textContent = ideology + (isStrong ? ' (Strong)' : '');
                roleSelect.appendChild(option);
            });
            
            // Allow same as faction if choosing Strong ideology
            const sameOption = document.createElement('option');
            sameOption.value = state.factionIdeology;
            sameOption.textContent = `${state.factionIdeology} (Same - pick Strong for Belief)`;
            roleSelect.appendChild(sameOption);
            
            state.roleIdeology = '';
            updateBeliefOptions();
            updateProficiencyTabs();
        }
        
        function updateBeliefOptions() {
            const select = document.getElementById('beliefIdeology');
            const roleIdeology = document.getElementById('roleIdeology').value;
            state.roleIdeology = roleIdeology;
            showIdeologyDesc('roleIdeologyDesc', roleIdeology);
            
            if (!roleIdeology) {
                select.disabled = true;
                select.innerHTML = '<option value="">-- Select role first --</option>';
                state.beliefIdeology = '';
                updateAversionOptions();
                return;
            }
            
            const faction = FACTIONS[state.faction];
            select.disabled = false;
            select.innerHTML = '<option value="">-- Choose Belief Ideology --</option>';
            
            // Can't use faction or role
            const excluded = new Set([state.factionIdeology, state.roleIdeology]);
            
            // If role same as faction, must pick from faction's Strong ideologies
            if (state.roleIdeology === state.factionIdeology) {
                faction.strong.forEach(ideology => {
                    const option = document.createElement('option');
                    option.value = ideology;
                    option.textContent = ideology + ' (Strong)';
                    select.appendChild(option);
                });
            } else {
                IDEOLOGIES.filter(i => !excluded.has(i)).forEach(ideology => {
                    const isStrong = faction.strong.includes(ideology);
                    const option = document.createElement('option');
                    option.value = ideology;
                    option.textContent = ideology + (isStrong ? ' (Strong)' : '');
                    select.appendChild(option);
                });
            }
            
            state.beliefIdeology = '';
            updateAversionOptions();
            updateProficiencyTabs();
        }
        
        function updateAversionOptions() {
            const select = document.getElementById('aversionIdeology');
            const beliefIdeology = document.getElementById('beliefIdeology').value;
            state.beliefIdeology = beliefIdeology;
            showIdeologyDesc('beliefIdeologyDesc', beliefIdeology);
            
            if (!beliefIdeology) {
                select.disabled = true;
                select.innerHTML = '<option value="">-- Select belief first --</option>';
                state.aversionIdeology = '';
                updateProficiencyTabs();
                validate();
                return;
            }
            
            const faction = FACTIONS[state.faction];
            select.disabled = false;
            select.innerHTML = '<option value="">-- Choose Aversion Ideology --</option>';
            
            // Can't use faction, role, or belief
            const excluded = new Set([state.factionIdeology, state.roleIdeology, state.beliefIdeology]);
            
            IDEOLOGIES.filter(i => !excluded.has(i)).forEach(ideology => {
                const isWeak = faction.weak.includes(ideology);
                const option = document.createElement('option');
                option.value = ideology;
                option.textContent = ideology + (isWeak ? ' (Weak)' : '');
                select.appendChild(option);
            });
            
            state.aversionIdeology = '';
            updateProficiencyTabs();
            validate();
        }
        
        function updateAversion() {
            state.aversionIdeology = document.getElementById('aversionIdeology').value;
            showIdeologyDesc('aversionIdeologyDesc', state.aversionIdeology, true);
            clearInvalidProficiencies();
            updateSecondaryIdeologies();
            updateProficiencyTabs();
            validate();
        }
        
        function updateSecondaryIdeologies() {
            const container = document.getElementById('secondaryIdeologies');
            const needsSecond = needsSecondaryIdeologies();
            
            container.style.display = needsSecond ? 'block' : 'none';
            
            if (!needsSecond) {
                state.secondBeliefIdeology = '';
                state.secondAversionIdeology = '';
                showIdeologyDesc('secondBeliefIdeologyDesc', null);
                showIdeologyDesc('secondAversionIdeologyDesc', null);
                return;
            }
            
            const usedIdeologies = new Set([
                state.factionIdeology, state.roleIdeology, 
                state.beliefIdeology, state.aversionIdeology
            ].filter(Boolean));
            
            // Second Belief (only for Ideologist advantage)
            const secondBeliefSelect = document.getElementById('secondBeliefIdeology');
            if (needsSecondBelief()) {
                secondBeliefSelect.parentElement.style.display = 'block';
                const currentValue = state.secondBeliefIdeology;
                secondBeliefSelect.innerHTML = '<option value="">-- Choose Second Belief --</option>';
                IDEOLOGIES.filter(i => !usedIdeologies.has(i)).forEach(ideology => {
                    const option = document.createElement('option');
                    option.value = ideology;
                    option.textContent = ideology;
                    if (ideology === currentValue) option.selected = true;
                    secondBeliefSelect.appendChild(option);
                });
                // Show description if value is set
                if (state.secondBeliefIdeology) {
                    showIdeologyDesc('secondBeliefIdeologyDesc', state.secondBeliefIdeology);
                }
            } else {
                secondBeliefSelect.parentElement.style.display = 'none';
                showIdeologyDesc('secondBeliefIdeologyDesc', null);
            }
            
            // Second Aversion
            const secondAversionSelect = document.getElementById('secondAversionIdeology');
            const usedForAversion = new Set([...usedIdeologies, state.secondBeliefIdeology].filter(Boolean));
            const currentAversionValue = state.secondAversionIdeology;
            secondAversionSelect.innerHTML = '<option value="">-- Choose Second Aversion --</option>';
            IDEOLOGIES.filter(i => !usedForAversion.has(i)).forEach(ideology => {
                const option = document.createElement('option');
                option.value = ideology;
                option.textContent = ideology;
                if (ideology === currentAversionValue) option.selected = true;
                secondAversionSelect.appendChild(option);
            });
            // Show description if value is set
            if (state.secondAversionIdeology) {
                showIdeologyDesc('secondAversionIdeologyDesc', state.secondAversionIdeology, true);
            }
        }
        
        function updateProficiencyTabs(preserveScroll = false) {
            const tabsContainer = document.getElementById('profTabs');
            const contentContainer = document.getElementById('profTabContent');
            const requirementsDiv = document.getElementById('proficiencyRequirements');
            const effectsDiv = document.getElementById('profEffects');
            
            // Save scroll position if preserving - the scrollable element is .proficiency-list inside the active tab
            const activeContent = contentContainer.querySelector('.tab-content.active');
            const activeProfList = activeContent ? activeContent.querySelector('.proficiency-list') : null;
            const scrollTop = preserveScroll && activeProfList ? activeProfList.scrollTop : 0;
            
            const favoured = getFavouredIdeologies();
            const baseSlots = getBaseProficiencySlots();
            const bonusProfs = getFactionBonusProficiencies();
            const profXPCost = getExtraProficiencyXPCost();
            
            // Show effects
            const effects = [];
            if (state.advantages.includes('Alternative Interpretation')) {
                effects.push('Alternative Interpretation: Can learn from Aversion');
            }
            if (state.drawbacks.includes('Tunnel Vision')) {
                effects.push('Tunnel Vision: Can ONLY learn from favoured ideologies');
            }
            if (bonusProfs.length > 0) {
                effects.push(`Faction Bonus: ${bonusProfs.length} starting proficiency(s) (★ marked)`);
            }
            
            // Show proficiency costs info
            if (profXPCost > 0) {
                effects.push(`<span style="color: var(--warning);">Extra Proficiency Cost: ${profXPCost} XP</span>`);
            }
            effects.push(`<span style="color: var(--text-dim); font-size: 0.85em;">Extra profs: Favoured = 2 XP | Unfavoured = 5 XP | Cannot learn from Aversion</span>`);
            
            effectsDiv.innerHTML = effects.length > 0 ? 
                `<div class="effect-notice">${effects.join('<br>')}</div>` : '';
            
            if (favoured.length === 0) {
                tabsContainer.innerHTML = '<span style="color: var(--text-dim); font-size: 0.85em;">Select ideologies first</span>';
                contentContainer.innerHTML = '';
                requirementsDiv.innerHTML = '';
                return;
            }
            
            // Requirements display - only base slot proficiencies count (not granted)
            const countBaseSlotProfsFromIdeology = (ideology) => {
                const profsInIdeology = state.proficiencies.filter(p => p.ideology === ideology);
                const grantedMap = buildGrantedProfsMap();
                const grantedUsed = {};
                let count = 0;
                
                profsInIdeology.forEach(p => {
                    const key = `${p.name}|${p.ideology}`;
                    
                    // Check if this is a granted proficiency
                    const grantedCount = grantedMap.get(key) || 0;
                    const used = grantedUsed[key] || 0;
                    if (used < grantedCount) {
                        grantedUsed[key] = used + 1;
                        return; // Granted, doesn't count toward requirement
                    }
                    
                    // This is a base slot proficiency
                    count++;
                });
                
                return count;
            };
            
            const hasFaction = countBaseSlotProfsFromIdeology(state.factionIdeology) >= 1;
            const hasRole = countBaseSlotProfsFromIdeology(state.roleIdeology) >= 1;
            const hasBelief = countBaseSlotProfsFromIdeology(state.beliefIdeology) >= 1;
            
            requirementsDiv.innerHTML = `
                <li>
                    <span class="check ${hasFaction ? 'pass' : 'fail'}">${hasFaction ? '✓' : '✗'}</span>
                    At least 1 from Faction (${state.factionIdeology})
                </li>
                <li>
                    <span class="check ${hasRole ? 'pass' : 'fail'}">${hasRole ? '✓' : '✗'}</span>
                    At least 1 from Role (${state.roleIdeology})
                </li>
                <li>
                    <span class="check ${hasBelief ? 'pass' : 'fail'}">${hasBelief ? '✓' : '✗'}</span>
                    At least 1 from Belief (${state.beliefIdeology})
                </li>
            `;
            
            // Determine tabs to show - now show ALL ideologies that can be learned from
            const hasTunnelVision = state.drawbacks.includes('Tunnel Vision');
            let tabIdeologies;
            if (hasTunnelVision) {
                // Tunnel Vision: can ONLY learn from favoured
                tabIdeologies = [...favoured];
            } else {
                // Show all ideologies - favoured ones first, then unfavoured
                tabIdeologies = [...favoured, ...IDEOLOGIES.filter(i => !favoured.includes(i) && canLearnFromIdeology(i))];
            }
            
            // Keep current tab if still valid
            let activeTab = state.currentProfTab;
            if (!activeTab || !tabIdeologies.includes(activeTab)) {
                activeTab = tabIdeologies[0];
                state.currentProfTab = activeTab;
            }
            
            // Generate tabs
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
            
            tabIdeologies.forEach((ideology) => {
                const isActive = ideology === activeTab;
                const isFavoured = favoured.includes(ideology);
                const isUnfavoured = !isFavoured;
                const isBonus = ideology === state.factionIdeology;
                const aversions = getAversionIdeologies();
                const isAversion = aversions.includes(ideology);
                
                const tab = document.createElement('button');
                let tabClass = 'tab';
                if (isActive) tabClass += ' active';
                if (isAversion) tabClass += ' aversion';
                else if (isBonus) tabClass += ' bonus';
                else if (isUnfavoured) tabClass += ' unfavoured';
                tab.className = tabClass;
                tab.textContent = ideology;
                tab.onclick = () => switchTab(ideology);
                tabsContainer.appendChild(tab);
                
                const content = document.createElement('div');
                content.className = 'tab-content' + (isActive ? ' active' : '');
                content.id = `tab-${ideology}`;
                
                const profList = document.createElement('div');
                profList.className = 'proficiency-list';
                
                const proficiencyData = PROFICIENCIES[ideology];
                
                // Build map of all granted proficiencies (these don't consume slots)
                const grantedProfsMap = new Map();
                
                // Faction bonus proficiencies
                bonusProfs.forEach(bp => {
                    const key = `${bp.name}|${bp.ideology}`;
                    grantedProfsMap.set(key, (grantedProfsMap.get(key) || 0) + 1);
                });
                
                // Advantages with grantsProficiency property
                ADVANTAGES.forEach(adv => {
                    if (adv.grantsProficiency && state.advantages.includes(adv.name)) {
                        const key = `${adv.grantsProficiency.name}|${adv.grantsProficiency.ideology}`;
                        grantedProfsMap.set(key, (grantedProfsMap.get(key) || 0) + 1);
                    }
                });
                
                // Earthling granted proficiencies
                if (state.advantages.includes('Earthling')) {
                    const earthlingChoice = getAdvantageChoice('Earthling');
                    if (earthlingChoice?.proficiencies) {
                        earthlingChoice.proficiencies.forEach(ep => {
                            if (ep && ep.name && ep.ideology) {
                                const key = `${ep.name}|${ep.ideology}`;
                                grantedProfsMap.set(key, (grantedProfsMap.get(key) || 0) + 1);
                            }
                        });
                    }
                }
                
                // Skilled granted proficiencies
                if (state.advantages.includes('Skilled')) {
                    const skilledChoices = state.advantageChoices['Skilled'] || [];
                    skilledChoices.forEach(sp => {
                        if (sp && sp.name && sp.ideology) {
                            const key = `${sp.name}|${sp.ideology}`;
                            grantedProfsMap.set(key, (grantedProfsMap.get(key) || 0) + 1);
                        }
                    });
                }
                
                // Versatile free proficiency
                const versatileChoice = getAdvantageChoice('Versatile');
                if (versatileChoice && versatileChoice.proficiency && versatileChoice.ideology) {
                    const key = `${versatileChoice.proficiency}|${versatileChoice.ideology}`;
                    grantedProfsMap.set(key, (grantedProfsMap.get(key) || 0) + 1);
                }
                
                // Count proficiencies that actually consume slots (only favoured, excluding all granted)
                let slotsFilled = 0;
                const grantedUsedTracker = {};
                
                state.proficiencies.forEach(p => {
                    const key = `${p.name}|${p.ideology}`;
                    
                    // Check if this is a granted proficiency (free, doesn't consume slot)
                    const grantedCount = grantedProfsMap.get(key) || 0;
                    const usedGranted = grantedUsedTracker[key] || 0;
                    if (usedGranted < grantedCount) {
                        grantedUsedTracker[key] = usedGranted + 1;
                        return; // Free, doesn't consume slot
                    }
                    
                    // Only favoured proficiencies consume slots
                    if (favoured.includes(p.ideology)) {
                        slotsFilled++;
                    }
                    // Unfavoured always cost XP, don't consume slots
                });
                
                const freeSlots = baseSlots; // Always 6 (or 5 with Unskilled)
                const isInExtraSlots = slotsFilled >= freeSlots;
                
                // Calculate cost for adding a proficiency from this ideology
                // Unfavoured/aversion costs 5 XP (or 4 with Flexible Thinker)
                // Favoured: base slots are free, extra slots cost 2 XP
                // Easily Bored: +1 XP for duplicates that cost XP
                const hasFlexibleThinker = state.advantages.includes('Flexible Thinker');
                const hasEasilyBored = state.drawbacks.includes('Easily Bored');
                const getAddCost = (profName) => {
                    let baseCost = 0;
                    if (!isFavoured) {
                        baseCost = hasFlexibleThinker ? 4 : 5; // Unfavoured/aversion
                    } else if (isInExtraSlots) {
                        baseCost = 2; // Extra favoured costs 2 XP
                    }
                    // Easily Bored: +1 if this would be a duplicate and costs XP
                    if (hasEasilyBored && baseCost > 0 && profName) {
                        const existingCount = state.proficiencies.filter(p => p.name === profName && p.ideology === ideology).length;
                        if (existingCount > 0) {
                            baseCost += 1;
                        }
                    }
                    return baseCost;
                };
                
                Object.keys(proficiencyData).forEach(prof => {
                    const desc = proficiencyData[prof];
                    const profInstances = state.proficiencies.filter(p => p.name === prof && p.ideology === ideology);
                    const profCount = profInstances.length;
                    const isSelected = profCount > 0;
                    const isBonus = isBonusProficiency(prof, ideology);
                    const canLearn = canLearnFromIdeology(ideology);
                    const canAfford = canAffordExtraProficiency(ideology);
                    
                    // Disabled if can't learn from ideology, OR if at XP limit and this would cost XP
                    const wouldCostXP = !isFavoured || isInExtraSlots;
                    const isDisabled = (!canLearn && !isBonus) || (!canAfford && wouldCostXP && !isSelected);
                    
                    // Check if this proficiency requires a choice
                    const choiceConfig = REQUIRES_CHOICE.proficiencies[prof];
                    const hasChoice = !!choiceConfig;
                    const choiceComplete = isChoiceComplete('proficiencies', prof, ideology);
                    
                    // Calculate cost display
                    const addCost = getAddCost(prof);
                    const costLabel = addCost > 0 ? ` [${addCost} XP]` : '';
                    
                    const item = document.createElement('div');
                    let itemClass = 'proficiency-item';
                    if (isSelected) itemClass += ' selected';
                    if (isBonus) itemClass += ' faction-bonus';
                    else if (isAversion) itemClass += ' aversion';
                    else if (isUnfavoured) itemClass += ' unfavoured';
                    if (isDisabled && !isSelected) itemClass += ' disabled';
                    item.className = itemClass;
                    
                    // Build the name with choice indicator
                    let nameClass = 'prof-name';
                    if (isSelected && hasChoice) {
                        nameClass += choiceComplete ? ' choice-complete' : ' has-choice-required';
                    }
                    
                    let choiceHTML = '';
                    if (isSelected && hasChoice) {
                        // For proficiencies with multiple instances, show one choice selector per instance
                        const choices = getProficiencyChoices(prof, ideology);
                        
                        for (let choiceIdx = 0; choiceIdx < profCount; choiceIdx++) {
                            const currentChoice = choices[choiceIdx] || null;
                            const currentValue = currentChoice?.value || '';
                            const choiceLabel = profCount > 1 ? `${choiceConfig.label} #${choiceIdx + 1}` : choiceConfig.label;
                            
                            choiceHTML += `<div class="choice-selector">
                                <label>${choiceLabel}</label>`;
                            
                            if (choiceConfig.type === 'ideology') {
                                // For Ally, Follower, Community - only show character's favoured ideologies
                                const isCharacterIdeologyChoice = ['Ally', 'Follower', 'Community'].includes(prof);
                                const availableIdeologies = isCharacterIdeologyChoice ? getFavouredIdeologies() : IDEOLOGIES;
                                
                                choiceHTML += `<select onchange="handleProficiencyChoiceChange('${prof}', '${ideology}', this.value, ${choiceIdx})" onclick="event.stopPropagation()">
                                    <option value="">-- Select Ideology --</option>`;
                                availableIdeologies.forEach(ideo => {
                                    const selected = currentValue === ideo ? 'selected' : '';
                                    choiceHTML += `<option value="${ideo}" ${selected}>${ideo}</option>`;
                                });
                                choiceHTML += `</select>`;
                            } else if (choiceConfig.type === 'text') {
                                const escapedValue = currentValue.replace(/"/g, '&quot;');
                                choiceHTML += `<input type="text" value="${escapedValue}" 
                                    placeholder="${choiceConfig.desc}"
                                    onchange="handleProficiencyChoiceChange('${prof}', '${ideology}', this.value, ${choiceIdx})"
                                    onclick="event.stopPropagation()">`;
                            }
                            
                            choiceHTML += `<div class="choice-desc">${choiceConfig.desc}</div></div>`;
                        }
                    }
                    
                    // Build multiple controls for selected proficiencies (including bonus profs)
                    let multipleControls = '';
                    let nextCostDisplay = '';
                    if (isSelected) {
                        // Calculate minimum count using the granted profs map
                        const key = `${prof}|${ideology}`;
                        const grantedMap = buildGrantedProfsMap();
                        const minCount = grantedMap.get(key) || 0;
                        
                        // Show cost to add the next one (same logic as addCost, which already handles duplicates)
                        if (addCost > 0) {
                            nextCostDisplay = ` <span class="prof-cost">[${addCost} XP]</span>`;
                        }
                        
                        const canRemove = profCount > minCount;
                        const canAddMore = canAfford; // Can only add more if we can afford the XP cost
                        multipleControls = `<div class="prof-multiple-controls" onclick="event.stopPropagation()">
                            <button class="multi-btn" onclick="removeProficiencyInstance('${prof}', '${ideology}')" ${!canRemove ? 'disabled' : ''} title="Remove one">−</button>
                            <span class="multi-count">${profCount}</span>
                            <button class="multi-btn" onclick="toggleProficiency('${prof}', '${ideology}')" ${!canAddMore ? 'disabled' : ''} title="${canAddMore ? 'Add another' + costLabel : 'XP limit reached'}">+</button>
                        </div>`;
                    }
                    
                    // Show cost to add next proficiency (for both selected and unselected)
                    const displayCost = addCost > 0 ? ` <span class="prof-cost">[${addCost} XP]</span>` : '';
                    
                    item.innerHTML = `
                        <input type="checkbox" ${isSelected ? 'checked' : ''} ${(isDisabled && !isSelected) ? 'disabled' : ''}>
                        <div class="prof-details">
                            <span class="${nameClass}">${prof}${profCount > 1 ? ` (×${profCount})` : ''}${isBonus && isSelected ? ' ★' : ''}${displayCost}</span>
                            <span class="prof-desc">${desc}</span>
                            ${choiceHTML}
                        </div>
                        ${multipleControls}
                    `;
                    
                    // Click to toggle: if selected, remove one; if not selected, add one
                    if (!isDisabled || isSelected) {
                        const handler = (e) => {
                            // Don't toggle if clicking on choice selector or multiple controls
                            if (e.target.closest('.choice-selector') || e.target.closest('.prof-multiple-controls')) return;
                            e.stopPropagation();
                            if (isSelected) {
                                // Remove one instance (unless it's the only bonus instance)
                                removeProficiencyInstance(prof, ideology);
                            } else {
                                // Add new proficiency
                                toggleProficiency(prof, ideology);
                            }
                        };
                        item.onclick = handler;
                    }
                    
                    profList.appendChild(item);
                });
                
                content.appendChild(profList);
                contentContainer.appendChild(content);
            });
            
            updateSelectedProficiencies();
            updateProfCounter();
            
            // Restore scroll position if preserving - use requestAnimationFrame to ensure DOM is updated
            if (preserveScroll && scrollTop > 0) {
                requestAnimationFrame(() => {
                    const newActiveContent = contentContainer.querySelector('.tab-content.active');
                    const newProfList = newActiveContent ? newActiveContent.querySelector('.proficiency-list') : null;
                    if (newProfList) {
                        newProfList.scrollTop = scrollTop;
                    }
                });
            }
        }
        
        function switchTab(ideology) {
            state.currentProfTab = ideology;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            const tabs = document.querySelectorAll('.tab');
            const favoured = getFavouredIdeologies();
            let tabIdeologies = [...favoured];
            if (state.advantages.includes('Versatile') || state.advantages.includes('Alternative Interpretation')) {
                tabIdeologies = IDEOLOGIES.filter(i => canLearnFromIdeology(i));
            }
            
            const tabIndex = tabIdeologies.indexOf(ideology);
            if (tabIndex >= 0 && tabs[tabIndex]) {
                tabs[tabIndex].classList.add('active');
            }
            const tabContent = document.getElementById(`tab-${ideology}`);
            if (tabContent) tabContent.classList.add('active');
        }
        
        function toggleProficiency(name, ideology) {
            const instances = state.proficiencies.filter(p => p.name === name && p.ideology === ideology);
            const isBonus = isBonusProficiency(name, ideology);
            
            if (instances.length > 0) {
                // Already have this - add another instance (XP cost handled by getExtraProficiencyXPCost)
                if (canLearnFromIdeology(ideology)) {
                    state.proficiencies.push({ name, ideology });
                }
            } else if (!isBonus) {
                // Adding a new non-bonus proficiency
                if (canLearnFromIdeology(ideology)) {
                    state.proficiencies.push({ name, ideology });
                }
            }
            // Note: First instance of bonus proficiencies are added automatically, not through toggle
            
            updateXP();
            updateProficiencyTabs(true); // preserve scroll
            renderAdvantages(true); // preserve scroll
            updateIncomeDisplay();
            validate();
        }
        
        function removeProficiencyInstance(name, ideology) {
            const isBonus = isBonusProficiency(name, ideology);
            const instances = state.proficiencies.filter(p => p.name === name && p.ideology === ideology);
            
            // Can't remove if it's the only instance of a bonus proficiency
            if (isBonus && instances.length <= 1) return;
            
            const index = state.proficiencies.findIndex(p => p.name === name && p.ideology === ideology);
            if (index >= 0) {
                state.proficiencies.splice(index, 1);
                
                // Also remove the last choice for this proficiency
                const newCount = state.proficiencies.filter(p => p.name === name && p.ideology === ideology).length;
                removeProficiencyChoiceAtIndex(name, ideology, newCount);
            }
            
            updateXP();
            updateProficiencyTabs(true); // preserve scroll
            renderAdvantages(true); // preserve scroll
            updateIncomeDisplay();
            validate();
        }
        
        function updateSelectedProficiencies() {
            const container = document.getElementById('selectedProfs');
            
            if (state.proficiencies.length === 0) {
                container.innerHTML = '<span style="color: var(--text-dim); font-size: 0.85em;">None selected</span>';
                return;
            }
            
            // Group proficiencies by name+ideology
            const grouped = {};
            state.proficiencies.forEach(p => {
                const key = `${p.name}|${p.ideology}`;
                if (!grouped[key]) {
                    grouped[key] = { name: p.name, ideology: p.ideology, count: 0 };
                }
                grouped[key].count++;
            });
            
            // Check which proficiencies are granted by advantages (with counts)
            const grantedProfs = new Map();
            ADVANTAGES.forEach(adv => {
                if (adv.grantsProficiency && state.advantages.includes(adv.name)) {
                    const key = `${adv.grantsProficiency.name}|${adv.grantsProficiency.ideology}`;
                    grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
                }
            });
            
            // Add Earthling granted proficiencies
            if (state.advantages.includes('Earthling')) {
                const earthlingChoice = getAdvantageChoice('Earthling');
                if (earthlingChoice?.proficiencies) {
                    earthlingChoice.proficiencies.forEach(prof => {
                        if (prof && prof.name && prof.ideology) {
                            const key = `${prof.name}|${prof.ideology}`;
                            grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
                        }
                    });
                }
            }
            
            // Add Skilled granted proficiencies
            if (state.advantages.includes('Skilled')) {
                const skilledChoices = state.advantageChoices['Skilled'] || [];
                skilledChoices.forEach(prof => {
                    if (prof && prof.name && prof.ideology) {
                        const key = `${prof.name}|${prof.ideology}`;
                        grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
                    }
                });
            }
            
            container.innerHTML = Object.values(grouped).map(p => {
                const key = `${p.name}|${p.ideology}`;
                const isBonus = isBonusProficiency(p.name, p.ideology);
                const bonusCount = isBonus ? 1 : 0;
                
                // Check if this is the Versatile free proficiency
                const versatileChoice = getAdvantageChoice('Versatile');
                const isVersatile = versatileChoice && 
                    versatileChoice.proficiency === p.name && 
                    versatileChoice.ideology === p.ideology;
                const versatileCount = isVersatile ? 1 : 0;
                
                // Check if this is a granted proficiency (from an advantage) - can be multiple
                const grantedCount = grantedProfs.get(key) || 0;
                
                // Extra count is everything minus special categories
                const extraCount = p.count - bonusCount - versatileCount - grantedCount;
                
                // Build HTML for each category
                let html = '';
                const favoured = getFavouredIdeologies();
                const aversions = getAversionIdeologies();
                const isFavoured = favoured.includes(p.ideology);
                const isAversion = aversions.includes(p.ideology);
                
                // Show bonus pill (yellow star)
                if (isBonus) {
                    html += `<span class="selected-prof faction-bonus">
                        ${p.name} <small>(${p.ideology.substring(0,3)})</small> ★
                    </span>`;
                }
                
                // Show versatile pill (purple lightning) - separate from bonus
                if (isVersatile) {
                    html += `<span class="selected-prof versatile">
                        ${p.name} <small>(${p.ideology.substring(0,3)})</small> ⚡
                    </span>`;
                }
                
                // Show granted pills (purple diamond) - one for each granted instance
                for (let i = 0; i < grantedCount; i++) {
                    html += `<span class="selected-prof granted">
                        ${p.name} <small>(${p.ideology.substring(0,3)})</small> ✦
                    </span>`;
                }
                
                // Show extra/regular selections (blue/grey/red with remove button)
                if (extraCount > 0) {
                    const countDisplay = extraCount > 1 ? ` ×${extraCount}` : '';
                    let styleClass = '';
                    if (isAversion) styleClass = ' aversion';
                    else if (!isFavoured) styleClass = ' unfavoured';
                    html += `<span class="selected-prof${styleClass}">
                        ${p.name}${countDisplay} <small>(${p.ideology.substring(0,3)})</small>
                        <span class="remove" onclick="event.stopPropagation(); removeProficiencyInstance('${p.name}', '${p.ideology}')">×</span>
                    </span>`;
                }
                return html;
            }).join('');
        }
        
        function updateProfCounter() {
            const counter = document.getElementById('profCounter');
            const baseSlots = getBaseProficiencySlots(); // 6 or 5 with Unskilled
            const profXP = getExtraProficiencyXPCost();
            
            // Count how many slots are used (favoured profs that aren't granted)
            const favoured = getFavouredIdeologies();
            const grantedProfs = buildGrantedProfsMap();
            const grantedUsed = {};
            let slotsUsed = 0;
            
            state.proficiencies.forEach(p => {
                const key = `${p.name}|${p.ideology}`;
                
                // Check if granted
                const grantedCount = grantedProfs.get(key) || 0;
                const used = grantedUsed[key] || 0;
                if (used < grantedCount) {
                    grantedUsed[key] = used + 1;
                    return; // Granted, doesn't use slot
                }
                
                // Only favoured use slots
                if (favoured.includes(p.ideology)) {
                    slotsUsed++;
                }
            });
            
            let text = `(${Math.min(slotsUsed, baseSlots)}/${baseSlots})`;
            if (profXP > 0) {
                text += ` [${profXP} XP]`;
            }
            counter.textContent = text;
            counter.className = 'counter' + (profXP > 0 ? ' warning' : '');
        }
        
        // Helper to build the granted proficiencies map
        function buildGrantedProfsMap() {
            const grantedProfs = new Map();
            const bonusProfs = getFactionBonusProficiencies();
            
            // Faction bonus
            bonusProfs.forEach(bp => {
                const key = `${bp.name}|${bp.ideology}`;
                grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
            });
            
            // Advantages with grantsProficiency
            ADVANTAGES.forEach(adv => {
                if (adv.grantsProficiency && state.advantages.includes(adv.name)) {
                    const key = `${adv.grantsProficiency.name}|${adv.grantsProficiency.ideology}`;
                    grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
                }
            });
            
            // Earthling
            if (state.advantages.includes('Earthling')) {
                const earthlingChoice = getAdvantageChoice('Earthling');
                if (earthlingChoice?.proficiencies) {
                    earthlingChoice.proficiencies.forEach(p => {
                        if (p && p.name && p.ideology) {
                            const key = `${p.name}|${p.ideology}`;
                            grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
                        }
                    });
                }
            }
            
            // Skilled
            if (state.advantages.includes('Skilled')) {
                const skilledChoices = state.advantageChoices['Skilled'] || [];
                skilledChoices.forEach(p => {
                    if (p && p.name && p.ideology) {
                        const key = `${p.name}|${p.ideology}`;
                        grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
                    }
                });
            }
            
            // Versatile
            const versatileChoice = getAdvantageChoice('Versatile');
            if (versatileChoice && versatileChoice.proficiency && versatileChoice.ideology) {
                const key = `${versatileChoice.proficiency}|${versatileChoice.ideology}`;
                grantedProfs.set(key, (grantedProfs.get(key) || 0) + 1);
            }
            
            return grantedProfs;
        }
        
        function getCost(item) {
            if (item.variableCost && item.variableCost[state.faction]) {
                return item.variableCost[state.faction];
            }
            return item.cost;
        }
        
        function checkPrereq(item) {
            if (!item.prereqCheck) return true;
            return item.prereqCheck(state);
        }
        
        function renderAdvantages(preserveScroll = false) {
            const container = document.getElementById('advantagesList');
            
            // Save scroll position if preserving
            const scrollTop = preserveScroll ? container.scrollTop : 0;
            
            container.innerHTML = '';
            
            const bonusAdvantages = getFactionBonusAdvantages();
            const currentNetXP = getNetXP();
            
            ADVANTAGES.forEach(adv => {
                const isSelected = state.advantages.includes(adv.name);
                const isBonus = isBonusAdvantage(adv.name);
                const isExcluded = adv.excludeFactions?.includes(state.faction);
                const hasExcludedTrait = adv.excludes?.some(ex => 
                    state.advantages.includes(ex) || state.drawbacks.includes(ex)
                );
                const prereqMet = checkPrereq(adv);
                // Limit to 7 XP spent on advantages (excluding bonus advantages)
                const wouldExceedAdvCap = !isSelected && !isBonus && (getTotalAdvXP() + adv.cost > 7);
                // Check if adding this would take net XP below -7
                const wouldExceedNetCap = !isSelected && !isBonus && (currentNetXP - adv.cost < -7);
                const disabled = (isExcluded || hasExcludedTrait || wouldExceedAdvCap || wouldExceedNetCap || (!isSelected && !prereqMet)) && !isBonus;
                
                const item = document.createElement('div');
                item.className = 'advantage-item' + 
                    (isSelected ? ' selected' : '') + 
                    (isBonus ? ' faction-bonus' : '') +
                    (disabled && !isSelected ? ' disabled' : '');
                
                // Count instances of this advantage
                const advCount = state.advantages.filter(a => a === adv.name).length;
                
                let extraInfo = '';
                if (adv.prereqNote && !prereqMet && !isBonus) {
                    extraInfo += `<div class="adv-prereq">⚠ ${adv.prereqNote}</div>`;
                }
                if (adv.effectDesc) {
                    extraInfo += `<div class="adv-effect">★ ${adv.effectDesc}</div>`;
                }
                if (isBonus) {
                    extraInfo += `<div class="adv-effect" style="color: var(--faction-bonus);">★ Faction Bonus (free)</div>`;
                }
                if (adv.multiple && isSelected) {
                    extraInfo += `<div class="adv-effect" style="color: var(--accent);">Can take multiple times (${advCount}×)</div>`;
                }
                
                // Check if this advantage requires a choice
                const choiceConfig = REQUIRES_CHOICE.advantages[adv.name];
                const hasChoice = !!choiceConfig;
                const choiceComplete = isChoiceComplete('advantages', adv.name);
                
                // Build name class with choice indicator
                let nameClass = 'adv-name';
                if (isSelected && hasChoice) {
                    nameClass += choiceComplete ? ' choice-complete' : ' has-choice-required';
                }
                
                // Build choice HTML for selected items that need choices
                let choiceHTML = '';
                if (isSelected && hasChoice) {
                    if (adv.name === 'Practiced') {
                        choiceHTML = `<div class="choice-selector">
                            <label>${choiceConfig.label}</label>
                            ${renderPracticedChoices()}
                            <div class="choice-desc">${choiceConfig.desc}</div>
                        </div>`;
                    } else if (adv.name === 'Rising Star') {
                        choiceHTML = `<div class="choice-selector">
                            <label>${choiceConfig.label}</label>
                            ${renderRisingStarChoices()}
                            <div class="choice-desc">${choiceConfig.desc}</div>
                        </div>`;
                    } else if (adv.name === 'Versatile') {
                        choiceHTML = `<div class="choice-selector">
                            <label>${choiceConfig.label}</label>
                            ${renderVersatileChoices()}
                            <div class="choice-desc">${choiceConfig.desc}</div>
                        </div>`;
                    } else if (adv.name === 'Earthling') {
                        choiceHTML = `<div class="choice-selector">
                            <label>${choiceConfig.label}</label>
                            ${renderEarthlingChoices()}
                            <div class="choice-desc">${choiceConfig.desc}</div>
                        </div>`;
                    } else if (adv.name === 'Skilled') {
                        choiceHTML = `<div class="choice-selector">
                            <label>${choiceConfig.label}</label>
                            ${renderSkilledChoices(advCount)}
                            <div class="choice-desc">${choiceConfig.desc}</div>
                        </div>`;
                    } else if (choiceConfig.type === 'text' && choiceConfig.multiple && advCount > 1) {
                        // Multiple instances with text choices
                        choiceHTML = `<div class="choice-selector">
                            <label>${choiceConfig.label}</label>
                            ${renderMultipleAdvantageChoices(adv.name, advCount)}
                            <div class="choice-desc">${choiceConfig.desc}</div>
                        </div>`;
                    } else if (choiceConfig.type === 'text') {
                        const currentChoice = getAdvantageChoice(adv.name);
                        const currentValue = (currentChoice?.text || '').replace(/"/g, '&quot;');
                        choiceHTML = `<div class="choice-selector">
                            <label>${choiceConfig.label}</label>
                            <input type="text" value="${currentValue}" 
                                placeholder="${choiceConfig.desc}"
                                onchange="handleAdvantageChoiceChange('${adv.name}', this.value, 'text')"
                                onclick="event.stopPropagation()">
                            <div class="choice-desc">${choiceConfig.desc}</div>
                        </div>`;
                    }
                }
                
                // Build cost display with +/- for multiples
                let costDisplay = isBonus ? 'FREE' : `-${adv.cost}`;
                let multipleControls = '';
                
                // Show controls for any multiple advantage that is selected (including bonus)
                if (adv.multiple && isSelected) {
                    const canRemove = isBonus ? advCount > 1 : advCount >= 1;
                    const paidCount = isBonus ? advCount - 1 : advCount;
                    const addDisabled = getTotalAdvXP() + adv.cost > 7;
                    multipleControls = `<div class="multiple-controls" onclick="event.stopPropagation()">
                        <button class="multi-btn" onclick="removeAdvantageInstance('${adv.name}')" ${!canRemove ? 'disabled' : ''}>−</button>
                        <span class="multi-count">${advCount}</span>
                        <button class="multi-btn" onclick="addAdvantageInstance('${adv.name}')" ${addDisabled ? 'disabled' : ''}>+</button>
                    </div>`;
                    // Update cost display for bonus multiples
                    if (isBonus && paidCount > 0) {
                        costDisplay = `FREE + ${paidCount}×${adv.cost}`;
                    }
                }
                
                item.innerHTML = `
                    <div class="adv-content">
                        <div class="${nameClass}">${adv.name}${adv.creationOnly ? ' ⓘ' : ''}${advCount > 1 ? ` (×${advCount})` : ''}</div>
                        <div class="adv-description">${adv.desc}</div>
                        ${extraInfo}
                        ${choiceHTML}
                    </div>
                    <div class="adv-cost-area">
                        <span class="adv-cost">${isBonus && advCount === 1 ? 'FREE' : (isBonus ? `FREE (${-adv.cost * (advCount-1)})` : (advCount > 1 ? `-${adv.cost} (${-adv.cost * advCount})` : `-${adv.cost}`))}</span>
                        ${multipleControls}
                    </div>
                `;
                
                // Allow clicking for bonus multiples to add more, or for non-bonus
                if ((!disabled || isSelected) && (!isBonus || adv.multiple)) {
                    item.onclick = (e) => {
                        // Don't toggle if clicking on choice selector or multiple controls
                        if (e.target.closest('.choice-selector') || e.target.closest('.multiple-controls')) return;
                        toggleAdvantage(adv.name);
                    };
                }
                
                container.appendChild(item);
            });
            
            // Restore scroll position if preserving - use requestAnimationFrame to ensure DOM is updated
            if (preserveScroll && scrollTop > 0) {
                requestAnimationFrame(() => {
                    container.scrollTop = scrollTop;
                });
            }
        }
        
        function renderDrawbacks(preserveScroll = false) {
            const container = document.getElementById('drawbacksList');
            
            // Save scroll position if preserving
            const scrollTop = preserveScroll ? container.scrollTop : 0;
            
            container.innerHTML = '';
            
            DRAWBACKS.forEach(draw => {
                const isSelected = state.drawbacks.includes(draw.name);
                const isExcluded = draw.excludeFactions?.includes(state.faction);
                const hasExcludedTrait = draw.excludes?.some(ex => 
                    state.advantages.includes(ex) || state.drawbacks.includes(ex)
                );
                const prereqMet = checkPrereq(draw);
                const cost = getCost(draw);
                const wouldExceedCap = !isSelected && (getTotalDrawXP() + cost > 7);
                const disabled = isExcluded || hasExcludedTrait || wouldExceedCap || (!isSelected && !prereqMet);
                
                // Check if this drawback requires a choice
                const choiceConfig = REQUIRES_CHOICE.drawbacks[draw.name];
                const hasChoice = !!choiceConfig;
                const choiceComplete = isChoiceComplete('drawbacks', draw.name);
                
                // Build name class with choice indicator
                let nameClass = 'adv-name';
                if (isSelected && hasChoice) {
                    nameClass += choiceComplete ? ' choice-complete' : ' has-choice-required';
                }
                
                // Count instances of this drawback
                const drawCount = state.drawbacks.filter(d => d === draw.name).length;
                
                const item = document.createElement('div');
                item.className = 'drawback-item' + 
                    (isSelected ? ' selected' : '') + 
                    (disabled && !isSelected ? ' disabled' : '');
                
                let extraInfo = '';
                if (draw.prereqNote && !prereqMet) {
                    extraInfo += `<div class="adv-prereq">⚠ ${draw.prereqNote}</div>`;
                }
                if (draw.effectDesc) {
                    extraInfo += `<div class="adv-effect">★ ${draw.effectDesc}</div>`;
                }
                if (draw.multiple && isSelected) {
                    extraInfo += `<div class="adv-effect" style="color: var(--accent);">Can be taken multiple times (${drawCount}x)</div>`;
                }
                
                // Build choice HTML for selected items that need choices
                let choiceHTML = '';
                if (isSelected && hasChoice) {
                    if (choiceConfig.type === 'text' && choiceConfig.multiple && drawCount > 1) {
                        // Multiple instances with text choices
                        choiceHTML = `<div class="choice-selector">
                            <label>${choiceConfig.label}</label>
                            ${renderMultipleDrawbackChoices(draw.name, drawCount)}
                            <div class="choice-desc">${choiceConfig.desc}</div>
                        </div>`;
                    } else if (choiceConfig.type === 'text') {
                        const currentChoice = getDrawbackChoice(draw.name);
                        const currentValue = (currentChoice?.text || '').replace(/"/g, '&quot;');
                        choiceHTML = `<div class="choice-selector">
                            <label>${choiceConfig.label}</label>
                            <input type="text" value="${currentValue}" 
                                placeholder="${choiceConfig.desc}"
                                onchange="handleDrawbackChoiceChange('${draw.name}', this.value, 'text')"
                                onclick="event.stopPropagation()">
                            <div class="choice-desc">${choiceConfig.desc}</div>
                        </div>`;
                    }
                }
                
                // Build cost display with +/- for multiples
                let costDisplay = `+${cost}`;
                let multipleControls = '';
                if (draw.multiple && isSelected) {
                    multipleControls = `<div class="multiple-controls" onclick="event.stopPropagation()">
                        <button class="multi-btn" onclick="removeDrawbackInstance('${draw.name}')" ${drawCount <= 1 ? 'disabled' : ''}>−</button>
                        <span class="multi-count">${drawCount}</span>
                        <button class="multi-btn" onclick="addDrawbackInstance('${draw.name}')" ${getTotalDrawXP() + cost > 7 ? 'disabled' : ''}>+</button>
                    </div>`;
                }
                
                item.innerHTML = `
                    <div class="adv-content">
                        <div class="${nameClass}">${draw.name}${draw.creationOnly ? ' ⓘ' : ''}${drawCount > 1 ? ` (×${drawCount})` : ''}</div>
                        <div class="adv-description">${draw.desc}</div>
                        ${extraInfo}
                        ${choiceHTML}
                    </div>
                    <div class="adv-cost-area">
                        <span class="adv-cost">${costDisplay}${drawCount > 1 ? ` (+${cost * drawCount})` : ''}</span>
                        ${multipleControls}
                    </div>
                `;
                
                if (!disabled || isSelected) {
                    item.onclick = (e) => {
                        // Don't toggle if clicking on choice selector
                        if (e.target.closest('.choice-selector')) return;
                        toggleDrawback(draw.name);
                    };
                }
                
                container.appendChild(item);
            });
            
            // Restore scroll position if preserving - use requestAnimationFrame to ensure DOM is updated
            if (preserveScroll && scrollTop > 0) {
                requestAnimationFrame(() => {
                    container.scrollTop = scrollTop;
                });
            }
        }
        
        function toggleAdvantage(name) {
            const adv = ADVANTAGES.find(a => a.name === name);
            const isBonus = isBonusAdvantage(name);
            const currentCount = state.advantages.filter(a => a === name).length;
            const wasSelected = state.advantages.includes(name);
            
            // For bonus advantages that allow multiple, allow adding more instances
            if (isBonus && adv.multiple) {
                // Add another instance (costs XP) - limit to 7 XP total
                if (getTotalAdvXP() + adv.cost <= 7) {
                    state.advantages.push(name);
                }
            } else if (isBonus) {
                // Can't toggle single-instance bonus advantages
                return;
            } else {
                const index = state.advantages.indexOf(name);
                if (index >= 0) {
                    state.advantages.splice(index, 1);
                } else {
                    if (adv.multiple) {
                        state.advantages.push(name);
                    } else if (!state.advantages.includes(name)) {
                        state.advantages.push(name);
                    }
                }
            }
            
            // Handle advantages that grant proficiencies
            if (adv.grantsProficiency) {
                const gp = adv.grantsProficiency;
                const nowSelected = state.advantages.includes(name);
                
                if (nowSelected && !wasSelected) {
                    // Always add the granted proficiency (even if one exists from bonus)
                    // The display logic will handle showing it correctly
                    state.proficiencies.push({ name: gp.name, ideology: gp.ideology });
                } else if (!nowSelected && wasSelected) {
                    // Remove one instance of the granted proficiency
                    const idx = state.proficiencies.findIndex(p => p.name === gp.name && p.ideology === gp.ideology);
                    if (idx >= 0) {
                        state.proficiencies.splice(idx, 1);
                    }
                }
            }
            
            // Handle Earthling proficiency grants
            if (name === 'Earthling') {
                const nowSelected = state.advantages.includes(name);
                if (!nowSelected && wasSelected) {
                    // Remove Earthling granted proficiencies
                    const earthlingChoice = getAdvantageChoice('Earthling');
                    if (earthlingChoice?.proficiencies) {
                        earthlingChoice.proficiencies.forEach(ep => {
                            if (ep && ep.name && ep.ideology) {
                                const idx = state.proficiencies.findIndex(p => 
                                    p.name === ep.name && p.ideology === ep.ideology
                                );
                                if (idx >= 0) {
                                    state.proficiencies.splice(idx, 1);
                                }
                            }
                        });
                    }
                    // Clear the choice
                    delete state.advantageChoices['Earthling'];
                }
            }
            
            // Handle Skilled proficiency grants
            if (name === 'Skilled') {
                const nowSelected = state.advantages.includes(name);
                if (!nowSelected && wasSelected) {
                    // Remove all Skilled granted proficiencies
                    const skilledChoices = state.advantageChoices['Skilled'] || [];
                    skilledChoices.forEach(sp => {
                        if (sp && sp.name && sp.ideology) {
                            const idx = state.proficiencies.findIndex(p => 
                                p.name === sp.name && p.ideology === sp.ideology
                            );
                            if (idx >= 0) {
                                state.proficiencies.splice(idx, 1);
                            }
                        }
                    });
                    // Clear the choice
                    delete state.advantageChoices['Skilled'];
                }
            }
            
            // Clear invalid proficiencies if toggling proficiency-affecting advantages
            if (['Alternative Interpretation', 'Versatile'].includes(name)) {
                clearInvalidProficiencies();
            }
            
            updateXP();
            updateSecondaryIdeologies();
            updateProficiencyTabs(true);
            renderAdvantages(true);
            renderDrawbacks(true);
            updateIncomeDisplay();
            validate();
        }
        
        function toggleDrawback(name) {
            const index = state.drawbacks.indexOf(name);
            const draw = DRAWBACKS.find(d => d.name === name);
            
            if (index >= 0) {
                state.drawbacks.splice(index, 1);
            } else {
                if (draw.multiple) {
                    state.drawbacks.push(name);
                } else if (!state.drawbacks.includes(name)) {
                    state.drawbacks.push(name);
                }
            }
            
            // Handle Faction Rebel specially
            if (name === 'Faction Rebel') {
                updateFactionRebelSelector();
            }
            
            // Clear invalid proficiencies if toggling proficiency-affecting drawbacks
            if (['Tunnel Vision'].includes(name)) {
                clearInvalidProficiencies();
            }
            
            updateXP();
            updateSecondaryIdeologies();
            updateProficiencyTabs(true);
            renderAdvantages(true);
            renderDrawbacks(true);
            validate();
        }
        
        function addAdvantageInstance(name) {
            const adv = ADVANTAGES.find(a => a.name === name);
            if (!adv || !adv.multiple) return;
            if (getTotalAdvXP() + adv.cost > 7) return;
            state.advantages.push(name);
            updateXP();
            renderAdvantages(true);
            // Update proficiency tabs if Skilled changed (affects slot count)
            if (name === 'Skilled') {
                updateProficiencyTabs(true);
            }
            validate();
        }
        
        function removeAdvantageInstance(name) {
            const isBonus = isBonusAdvantage(name);
            const currentCount = state.advantages.filter(a => a === name).length;
            
            // Can't remove if it's the only instance of a bonus advantage
            if (isBonus && currentCount <= 1) return;
            
            const index = state.advantages.lastIndexOf(name);
            if (index >= 0) {
                state.advantages.splice(index, 1);
            }
            updateXP();
            renderAdvantages(true);
            // Update proficiency tabs if Skilled changed (affects slot count)
            if (name === 'Skilled') {
                updateProficiencyTabs(true);
            }
            validate();
        }
        
        function addDrawbackInstance(name) {
            const draw = DRAWBACKS.find(d => d.name === name);
            if (!draw || !draw.multiple) return;
            const cost = getCost(draw);
            if (getTotalDrawXP() + cost > 7) return;
            state.drawbacks.push(name);
            updateXP();
            renderDrawbacks(true);
            validate();
        }
        
        function removeDrawbackInstance(name) {
            const index = state.drawbacks.lastIndexOf(name);
            if (index >= 0) {
                state.drawbacks.splice(index, 1);
            }
            updateXP();
            renderDrawbacks(true);
            validate();
        }
        
        function getTotalAdvXP() {
            const bonusAdvantages = getFactionBonusAdvantages();
            // Track how many free instances we've counted for each bonus advantage
            const bonusUsed = {};
            
            return state.advantages.reduce((sum, name) => {
                const adv = ADVANTAGES.find(a => a.name === name);
                if (!adv) return sum;
                
                // Check if this is a bonus advantage
                if (bonusAdvantages.includes(name)) {
                    // Count how many free instances of this advantage exist in bonuses
                    const freeCount = bonusAdvantages.filter(b => b === name).length;
                    const usedCount = bonusUsed[name] || 0;
                    
                    if (usedCount < freeCount) {
                        // This instance is free
                        bonusUsed[name] = usedCount + 1;
                        return sum;
                    }
                }
                
                // This instance costs XP
                return sum + adv.cost;
            }, 0);
        }
        
        function getTotalDrawXP() {
            return state.drawbacks.reduce((sum, name) => {
                const draw = DRAWBACKS.find(d => d.name === name);
                return sum + (draw ? getCost(draw) : 0);
            }, 0);
        }
        
        function getTotalIncome() {
            if (!state.faction) return 0;
            const faction = FACTIONS[state.faction];
            let income = faction.startingIncome || 0;
            
            // Indebted drawback removes 2 income
            if (state.drawbacks.includes('Indebted')) {
                income -= 2;
            }
            
            // Energy proficiency adds +2 income per instance
            // Note: Energy Savings grants an Energy proficiency, so it's already counted here
            const energyCount = state.proficiencies.filter(p => p.name === 'Energy').length;
            income += energyCount * 2;
            
            return Math.max(0, income); // Can't go below 0
        }
        
        function getNutrientIncome() {
            let income = 0;
            
            // Nutrients proficiency adds +2 per instance
            // Note: Hydroponics Bay grants a Nutrients proficiency, so it's already counted here
            const nutrientCount = state.proficiencies.filter(p => p.name === 'Nutrients').length;
            income += nutrientCount * 2;
            
            // Farm proficiency also grants nutrients
            const farmCount = state.proficiencies.filter(p => p.name === 'Farm').length;
            income += farmCount * 2;
            
            return income;
        }
        
        function getMineralIncome() {
            let income = 0;
            
            // Minerals proficiency adds +2 per instance
            // Note: Rich Ore Seam grants a Minerals proficiency, so it's already counted here
            const mineralCount = state.proficiencies.filter(p => p.name === 'Minerals').length;
            income += mineralCount * 2;
            
            return income;
        }
        
        function getBreakthroughs() {
            let breakthroughs = 0;
            
            // Lab proficiency adds +1 per instance
            const labCount = state.proficiencies.filter(p => p.name === 'Lab').length;
            breakthroughs += labCount;
            
            // Spark of Genius advantage adds +1
            if (state.advantages.includes('Spark of Genius')) {
                breakthroughs += 1;
            }
            
            return breakthroughs;
        }
        
        function getFacilities() {
            let facilities = 1; // Default 1
            
            // Delegate proficiency adds +2 per instance
            const delegateCount = state.proficiencies.filter(p => p.name === 'Delegate').length;
            facilities += delegateCount * 2;
            
            // Management proficiency adds +2 per instance
            const managementCount = state.proficiencies.filter(p => p.name === 'Management').length;
            facilities += managementCount * 2;
            
            // Program proficiency adds +1 per instance
            const programCount = state.proficiencies.filter(p => p.name === 'Program').length;
            facilities += programCount;
            
            return facilities;
        }
        
        function updateIncomeDisplay() {
            const incomeEl = document.getElementById('incomeDisplay');
            if (incomeEl && state.faction) {
                const faction = FACTIONS[state.faction];
                let baseIncome = faction.startingIncome || 0;
                const totalIncome = getTotalIncome();
                
                // Show Indebted penalty
                if (state.drawbacks.includes('Indebted')) {
                    const penaltyIncome = Math.max(0, baseIncome - 2);
                    const bonus = totalIncome - penaltyIncome;
                    if (bonus > 0) {
                        incomeEl.innerHTML = `Starting Income: <span style="color: var(--danger);">${penaltyIncome}</span> <span style="color: var(--success);">(+${bonus})</span> = ${totalIncome} Energy/session`;
                    } else {
                        incomeEl.innerHTML = `Starting Income: <span style="color: var(--danger);">${totalIncome}</span> Energy/session (Indebted)`;
                    }
                } else {
                    const bonus = totalIncome - baseIncome;
                    if (bonus > 0) {
                        incomeEl.innerHTML = `Starting Income: ${baseIncome} <span style="color: var(--success);">(+${bonus})</span> = ${totalIncome} Energy/session`;
                    } else {
                        incomeEl.textContent = `Starting Income: ${totalIncome} Energy/session`;
                    }
                }
            }
        }
        
        function updateXP() {
            const advXP = getTotalAdvXP();
            const drawXP = getTotalDrawXP();
            const bonusXP = state.faction ? FACTIONS[state.faction].bonusXP : 0;
            const profXP = getExtraProficiencyXPCost();
            const totalSpent = advXP + profXP;
            const netXP = drawXP + bonusXP - totalSpent;
            
            // Display each XP category
            document.getElementById('profXP').textContent = profXP;
            document.getElementById('advXP').textContent = advXP;
            document.getElementById('drawXP').textContent = '+' + drawXP;
            document.getElementById('netXP').textContent = (netXP >= 0 ? '+' : '') + netXP;
            document.getElementById('netXP').style.color = netXP >= 0 ? 'var(--success)' : 'var(--error)';
            
            // Color proficiency XP if at/over limit
            const maxProfXP = getMaxProficiencyXP();
            document.getElementById('profXP').style.color = profXP >= maxProfXP ? 'var(--warning)' : '';
        }
        
        function validate() {
            const messages = [];
            let isValid = true;
            
            state.name = document.getElementById('charName').value;
            if (!state.name.trim()) {
                messages.push({ type: 'error', text: 'Character name required' });
                isValid = false;
            }
            
            if (!state.faction) {
                messages.push({ type: 'error', text: 'Select a faction' });
                isValid = false;
            }
            
            // Check Spartan equipment choice
            if (state.faction === 'spartans' && !state.spartanChoice) {
                messages.push({ type: 'error', text: 'Spartans must choose Weapon or Armour proficiency' });
                isValid = false;
            }
            
            if (!state.roleIdeology) {
                messages.push({ type: 'error', text: 'Select role ideology' });
                isValid = false;
            }
            if (!state.beliefIdeology) {
                messages.push({ type: 'error', text: 'Select belief ideology' });
                isValid = false;
            }
            if (!state.aversionIdeology) {
                messages.push({ type: 'error', text: 'Select aversion ideology' });
                isValid = false;
            }
            
            // Secondary ideologies
            if (needsSecondBelief() && !state.secondBeliefIdeology) {
                messages.push({ type: 'error', text: 'Select second belief (Ideologist)' });
                isValid = false;
            }
            if (needsSecondAversion() && !state.secondAversionIdeology) {
                messages.push({ type: 'error', text: 'Select second aversion' });
                isValid = false;
            }
            
            // Count base slot proficiencies towards ideology requirements
            // (excludes all granted: bonus, Versatile, Skilled, Earthling, advantage grants)
            const countBaseSlotProfsFromIdeology = (ideology) => {
                const profsInIdeology = state.proficiencies.filter(p => p.ideology === ideology);
                const grantedMap = buildGrantedProfsMap();
                const grantedUsed = {};
                let count = 0;
                
                profsInIdeology.forEach(p => {
                    const key = `${p.name}|${p.ideology}`;
                    
                    // Check if this is a granted proficiency
                    const grantedCount = grantedMap.get(key) || 0;
                    const used = grantedUsed[key] || 0;
                    if (used < grantedCount) {
                        grantedUsed[key] = used + 1;
                        return; // Granted, doesn't count toward requirement
                    }
                    
                    // This is a base slot proficiency
                    count++;
                });
                
                return count;
            };
            
            // Check minimum proficiency requirements from each ideology
            if (state.factionIdeology && countBaseSlotProfsFromIdeology(state.factionIdeology) < 1) {
                messages.push({ type: 'error', text: `Need 1+ from Faction (${state.factionIdeology})` });
                isValid = false;
            }
            if (state.roleIdeology && countBaseSlotProfsFromIdeology(state.roleIdeology) < 1) {
                messages.push({ type: 'error', text: `Need 1+ from Role (${state.roleIdeology})` });
                isValid = false;
            }
            if (state.beliefIdeology && countBaseSlotProfsFromIdeology(state.beliefIdeology) < 1) {
                messages.push({ type: 'error', text: `Need 1+ from Belief (${state.beliefIdeology})` });
                isValid = false;
            }
            
            const advXP = getTotalAdvXP();
            const drawXP = getTotalDrawXP();
            const bonusXP = state.faction ? FACTIONS[state.faction].bonusXP : 0;
            const profXP = getExtraProficiencyXPCost();
            const maxProfXP = getMaxProficiencyXP();
            const totalSpent = advXP + profXP;
            const netXP = drawXP + bonusXP - totalSpent;
            
            if (netXP < 0) {
                messages.push({ type: 'error', text: `XP balance negative (${netXP})` });
                isValid = false;
            }
            if (advXP > 7) {
                messages.push({ type: 'error', text: `Advantages exceed 7 XP (${advXP})` });
                isValid = false;
            }
            if (profXP > maxProfXP) {
                messages.push({ type: 'error', text: `Proficiencies exceed ${maxProfXP} XP (${profXP})` });
                isValid = false;
            }
            if (drawXP > 7) {
                messages.push({ type: 'error', text: `Drawbacks exceed 7 XP (${drawXP})` });
                isValid = false;
            }
            
            // Check for incomplete choices on proficiencies
            const incompleteProfs = state.proficiencies.filter(p => {
                return REQUIRES_CHOICE.proficiencies[p.name] && !isChoiceComplete('proficiencies', p.name, p.ideology);
            });
            if (incompleteProfs.length > 0) {
                messages.push({ type: 'warning', text: `Configure: ${incompleteProfs.map(p => p.name).join(', ')}` });
            }
            
            // Check for incomplete choices on advantages
            const incompleteAdvs = state.advantages.filter(name => {
                return REQUIRES_CHOICE.advantages[name] && !isChoiceComplete('advantages', name);
            });
            if (incompleteAdvs.length > 0) {
                messages.push({ type: 'warning', text: `Configure: ${[...new Set(incompleteAdvs)].join(', ')}` });
            }
            
            // Check for incomplete choices on drawbacks
            const incompleteDraws = state.drawbacks.filter(name => {
                return REQUIRES_CHOICE.drawbacks[name] && !isChoiceComplete('drawbacks', name);
            });
            if (incompleteDraws.length > 0) {
                messages.push({ type: 'warning', text: `Configure: ${incompleteDraws.join(', ')}` });
            }
            
            const container = document.getElementById('validationMessages');
            if (messages.length === 0 && isValid) {
                container.innerHTML = '<div class="validation-message success">✓ Character valid - ready to export!</div>';
            } else {
                container.innerHTML = messages.map(m => 
                    `<div class="validation-message ${m.type}">${m.text}</div>`
                ).join('');
            }
            
            document.getElementById('exportBtn').disabled = !isValid;
            document.getElementById('exportPdfBtn').disabled = !isValid;
            updateSummary();
            return isValid;
        }
        
        function updateSummary() {
            const container = document.getElementById('characterSummary');
            
            if (!state.faction) {
                container.innerHTML = '<p style="color: var(--text-dim); font-size: 0.85em;">Complete form to see summary</p>';
                return;
            }
            
            const faction = FACTIONS[state.faction];
            const advXP = getTotalAdvXP();
            const drawXP = getTotalDrawXP();
            const bonusAdvantages = getFactionBonusAdvantages();
            const bonusProfs = getFactionBonusProficiencies();
            
            container.innerHTML = `
                <div class="summary-grid">
                    <div class="summary-item">
                        <h4>Name</h4>
                        <div>${state.name || 'Not set'}</div>
                    </div>
                    <div class="summary-item">
                        <h4>Faction</h4>
                        <div>${faction.name}</div>
                    </div>
                    <div class="summary-item">
                        <h4>Ideologies</h4>
                        <div>F: ${state.factionIdeology || '-'}<br>R: ${state.roleIdeology || '-'}<br>B: ${state.beliefIdeology || '-'}<br>A: ${state.aversionIdeology || '-'}</div>
                    </div>
                    <div class="summary-item">
                        <h4>Proficiencies (${state.proficiencies.length}/${getMaxProficiencies()})</h4>
                        <div style="font-size:0.8em">${(() => {
                            // Group and track bonus usage
                            const grouped = {};
                            const bonusUsed = {};
                            state.proficiencies.forEach(p => {
                                const key = `${p.name}|${p.ideology}`;
                                if (!grouped[key]) {
                                    grouped[key] = { name: p.name, ideology: p.ideology, count: 0 };
                                }
                                grouped[key].count++;
                            });
                            
                            const items = [];
                            Object.values(grouped).forEach(p => {
                                const isBonus = isBonusProficiency(p.name, p.ideology);
                                if (isBonus) {
                                    items.push(`<span style="color: var(--faction-bonus);">${p.name}★</span>`);
                                }
                                const extraCount = p.count - (isBonus ? 1 : 0);
                                if (extraCount > 0) {
                                    items.push(p.name + (extraCount > 1 ? ` ×${extraCount}` : ''));
                                }
                            });
                            return items.join(', ') || 'None';
                        })()}</div>
                    </div>
                    <div class="summary-item">
                        <h4>Advantages (${advXP} XP${bonusAdvantages.length > 0 ? ' + ' + bonusAdvantages.length + ' free' : ''})</h4>
                        <div style="font-size:0.8em">${(() => {
                            // Track bonus usage - only first instance of each bonus is free
                            const bonusUsed = {};
                            const items = [];
                            state.advantages.forEach(a => {
                                const isBonusType = bonusAdvantages.includes(a);
                                const freeCount = bonusAdvantages.filter(b => b === a).length;
                                const usedCount = bonusUsed[a] || 0;
                                
                                if (isBonusType && usedCount < freeCount) {
                                    // This instance is free
                                    bonusUsed[a] = usedCount + 1;
                                    items.push(`<span style="color: var(--faction-bonus);">${a}★</span>`);
                                } else {
                                    items.push(a);
                                }
                            });
                            return items.join(', ') || 'None';
                        })()}</div>
                    </div>
                    <div class="summary-item">
                        <h4>Drawbacks (+${drawXP} XP)</h4>
                        <div style="font-size:0.8em">${state.drawbacks.join(', ') || 'None'}</div>
                    </div>
                    <div class="summary-item">
                        <h4>Resources</h4>
                        <div style="font-size:0.8em">
                            <span style="color: #ffc864;">Energy: ${getTotalIncome()}</span>${getTotalIncome() !== (state.drawbacks.includes('Indebted') ? Math.max(0, faction.startingIncome - 2) : faction.startingIncome) ? ' <span style="color: var(--text-dim);">(mod)</span>' : ''} · 
                            <span style="color: #64c864;">Nutrients: ${getNutrientIncome()}</span> · 
                            <span style="color: #b48c64;">Minerals: ${getMineralIncome()}</span>${getBreakthroughs() > 0 ? ` · <span style="color: #c8a0ff;">Breaks: ${getBreakthroughs()}</span>` : ''}${getFacilities() > 1 ? ` · <span style="color: #a0a0a0;">Facilities: ${getFacilities()}</span>` : ''}<br>
                            <span style="color: #ff4a6a;">Upkeep: ${getCharacterUpkeep()}</span>${state.advantages.includes('Benefactor') ? ' <span style="color: var(--text-dim);">(Benefactor)</span>' : ''}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function getCharacterUpkeep() {
            if (!state.faction) return 0;
            const isHive = state.faction === 'hive';
            const isMorgan = state.faction === 'morgan';
            const hasBenefactor = state.advantages.includes('Benefactor');
            const baseUpkeep = (isHive || hasBenefactor) ? 0 : 2;
            const optionalUpkeep = isMorgan ? 2 : 0;
            return baseUpkeep + optionalUpkeep;
        }
        
        function exportCharacter() {
            if (!validate()) return;
            
            state.name = document.getElementById('charName').value;
            state.concept = document.getElementById('charConcept').value;
            
            const faction = FACTIONS[state.faction];
            const bonusProfs = getFactionBonusProficiencies();
            const bonusAdvantages = getFactionBonusAdvantages();
            
            // Build proficiency export with all choices for each instance
            const proficiencyExport = [];
            const profGroups = {};
            state.proficiencies.forEach((p, idx) => {
                const key = `${p.name}|${p.ideology}`;
                if (!profGroups[key]) profGroups[key] = [];
                profGroups[key].push(idx);
            });
            
            Object.entries(profGroups).forEach(([key, indices]) => {
                const [name, ideology] = key.split('|');
                const choices = getProficiencyChoices(name, ideology);
                indices.forEach((origIdx, instanceIdx) => {
                    proficiencyExport.push({
                        name,
                        ideology,
                        isBonus: isBonusProficiency(name, ideology),
                        instanceIndex: instanceIdx,
                        choice: choices[instanceIdx] || null
                    });
                });
            });
            
            const exportData = {
                version: '1.3',
                exportDate: new Date().toISOString(),
                character: {
                    name: state.name,
                    concept: state.concept,
                    faction: {
                        key: state.faction,
                        name: faction.name,
                        leader: faction.leader,
                        bonusDescription: faction.bonusDescription
                    },
                    ideologies: {
                        faction: state.factionIdeology,
                        factionDefault: faction.dominant,
                        factionRebel: state.factionIdeology !== faction.dominant,
                        role: state.roleIdeology,
                        belief: state.beliefIdeology,
                        aversion: state.aversionIdeology,
                        secondBelief: state.secondBeliefIdeology || null,
                        secondAversion: state.secondAversionIdeology || null,
                        favoured: getFavouredIdeologies(),
                        allAversions: getAversionIdeologies()
                    },
                    proficiencies: proficiencyExport,
                    // Store raw proficiency choices for easy restore
                    proficiencyChoices: state.proficiencyChoices,
                    advantages: (() => {
                        const indices = {};
                        return state.advantages.map(name => {
                            const adv = ADVANTAGES.find(a => a.name === name);
                            const isBonus = isBonusAdvantage(name);
                            const choice = getAdvantageChoice(name);
                            const index = indices[name] || 0;
                            indices[name] = index + 1;
                            
                            // Get individual choice for this instance
                            let instanceChoice = choice;
                            if (Array.isArray(choice)) {
                                instanceChoice = choice[index] || null;
                            }
                            
                            return { 
                                name, 
                                cost: isBonus ? 0 : adv.cost, 
                                description: adv.desc,
                                isBonus,
                                choice: instanceChoice,
                                instanceIndex: index
                            };
                        });
                    })(),
                    // Store raw advantage choices for easy restore
                    advantageChoices: state.advantageChoices,
                    drawbacks: (() => {
                        const indices = {};
                        return state.drawbacks.map(name => {
                            const draw = DRAWBACKS.find(d => d.name === name);
                            const choice = getDrawbackChoice(name);
                            const index = indices[name] || 0;
                            indices[name] = index + 1;
                            
                            // Get individual choice for this instance
                            let instanceChoice = choice;
                            if (Array.isArray(choice)) {
                                instanceChoice = choice[index] || null;
                            }
                            
                            return { 
                                name, 
                                cost: getCost(draw), 
                                description: draw.desc,
                                choice: instanceChoice,
                                instanceIndex: index
                            };
                        });
                    })(),
                    // Store raw drawback choices for easy restore
                    drawbackChoices: state.drawbackChoices,
                    xp: {
                        advantagesSpent: getTotalAdvXP(),
                        drawbacksGained: getTotalDrawXP(),
                        factionBonus: faction.bonusXP,
                        proficiencyCost: getExtraProficiencyXPCost(),
                        net: getTotalDrawXP() + faction.bonusXP - getTotalAdvXP() - getExtraProficiencyXPCost()
                    },
                    resources: {
                        energyIncome: getTotalIncome(),
                        nutrientIncome: getNutrientIncome(),
                        mineralIncome: getMineralIncome(),
                        breakthroughs: getBreakthroughs(),
                        facilities: getFacilities(),
                        upkeep: getCharacterUpkeep()
                    },
                    startingIncome: faction.startingIncome,
                    totalIncome: getTotalIncome(),
                    characterUpkeep: getCharacterUpkeep(),
                    maxProficiencies: getMaxProficiencies(),
                    spartanChoice: state.spartanChoice
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${state.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_character.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function exportPDF() {
            // Update state from form before export
            state.concept = document.getElementById('charConcept').value;
            
            if (!validate()) return;
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            const pageWidth = doc.internal.pageSize.getWidth();
            const pageHeight = doc.internal.pageSize.getHeight();
            const margin = 12;
            const contentWidth = pageWidth - (margin * 2);
            let y = margin;
            
            const faction = FACTIONS[state.faction];
            const bonusProfs = getFactionBonusProficiencies();
            const bonusAdvantages = getFactionBonusAdvantages();
            const grantedMap = buildGrantedProfsMap();
            const favoured = getFavouredIdeologies();
            const aversions = getAversionIdeologies();
            
            // Colors matching web page
            const colors = {
                primary: [74, 158, 255],
                secondary: [74, 255, 159],
                accent: [74, 255, 159],
                energy: [255, 200, 100], // Gold for energy
                danger: [255, 74, 106],
                warning: [255, 170, 74],
                factionBonus: [212, 175, 55],
                versatile: [180, 100, 255],
                unfavoured: [128, 128, 128],
                aversion: [255, 100, 100],
                text: [224, 232, 240],
                textLight: [128, 144, 160],
                bgDark: [10, 15, 20],
                bgMedium: [19, 26, 34],
                bgLight: [26, 35, 45],
                border: [42, 58, 74],
                pillBg: [30, 40, 50],
                pillBgBonus: [50, 45, 20],
                pillBgVersatile: [45, 30, 60],
                pillBgUnfavoured: [40, 40, 45],
                pillBgAversion: [50, 30, 35]
            };
            
            function drawBox(x, y, w, h, color, borderColor) {
                doc.setFillColor(...color);
                doc.roundedRect(x, y, w, h, 2, 2, 'F');
                if (borderColor) {
                    doc.setDrawColor(...borderColor);
                    doc.setLineWidth(0.3);
                    doc.roundedRect(x, y, w, h, 2, 2, 'S');
                }
            }
            
            function drawPill(x, y, text, bgColor, textColor, borderColor) {
                doc.setFontSize(8);
                doc.setFont('helvetica', 'normal');
                const textWidth = doc.getTextWidth(text);
                const pillW = textWidth + 6;
                const pillH = 7;
                doc.setFillColor(...bgColor);
                doc.roundedRect(x, y, pillW, pillH, 2, 2, 'F');
                if (borderColor) {
                    doc.setDrawColor(...borderColor);
                    doc.setLineWidth(0.3);
                    doc.roundedRect(x, y, pillW, pillH, 2, 2, 'S');
                }
                doc.setTextColor(...textColor);
                doc.text(text, x + 3, y + 5);
                return pillW + 3;
            }
            
            function drawCheckbox(x, y, checked, fillColor) {
                doc.setDrawColor(...colors.textLight);
                doc.setLineWidth(0.3);
                doc.rect(x, y, 4, 4, 'S');
                if (checked) {
                    doc.setFillColor(...(fillColor || colors.accent));
                    doc.rect(x + 0.5, y + 0.5, 3, 3, 'F');
                }
                return 6;
            }
            
            function addFooter() {
                doc.setFontSize(6);
                doc.setTextColor(...colors.textLight);
                doc.text('Awakening Chiron Character Sheet', margin, pageHeight - 5);
                doc.text(`Generated: ${new Date().toLocaleDateString()}`, pageWidth - margin, pageHeight - 5, { align: 'right' });
            }
            
            // Background
            doc.setFillColor(...colors.bgDark);
            doc.rect(0, 0, pageWidth, pageHeight, 'F');
            
            // === HEADER ROW: Title | Name (full width) ===
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('AWAKENING CHIRON', margin, y + 6);
            
            // Name box (expanded to fill remaining space)
            const nameBoxX = margin + 70;
            const nameBoxW = contentWidth - 70;
            drawBox(nameBoxX, y, nameBoxW, 12, colors.bgMedium);
            doc.setFontSize(6);
            doc.setTextColor(...colors.textLight);
            doc.text('NAME', nameBoxX + 2, y + 4);
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.text);
            doc.text(state.name || 'Unnamed', nameBoxX + 2, y + 10);
            
            y += 15;
            
            // === CONCEPT BOX (Large - ~1/3 page) ===
            const conceptBoxHeight = 70;
            drawBox(margin, y, contentWidth, conceptBoxHeight, colors.bgMedium, colors.primary);
            
            doc.setFontSize(8);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('CHARACTER CONCEPT', margin + 4, y + 6);
            
            doc.setFontSize(9);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...colors.text);
            const concept = state.concept || 'No concept defined';
            const conceptLines = doc.splitTextToSize(concept, contentWidth - 8);
            doc.text(conceptLines.slice(0, 12), margin + 4, y + 14);
            
            y += conceptBoxHeight + 4;
            
            // === FACTION BONUS BOX (with faction name as title, no &) ===
            let bonusParts = [faction.bonusDescription];
            if (bonusProfs.length > 0) {
                bonusParts.push(`Bonus Proficiency: ${bonusProfs.map(p => p.name).join(', ')}`);
            }
            if (bonusAdvantages.length > 0) {
                bonusParts.push(`Bonus Advantage: ${bonusAdvantages.join(', ')}`);
            }
            if (faction.bonusXP > 0) {
                bonusParts.push(`+${faction.bonusXP} Bonus XP`);
            }
            const bonusText = bonusParts.join(' | ');
            
            const bonusLines = doc.splitTextToSize(bonusText, contentWidth - 60);
            const bonusBoxHeight = Math.max(12, 6 + (bonusLines.length * 4));
            drawBox(margin, y, contentWidth, bonusBoxHeight, [33, 28, 15], colors.factionBonus);
            
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.factionBonus);
            doc.text(faction.name.toUpperCase(), margin + 3, y + 7);
            
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...colors.text);
            bonusLines.forEach((line, i) => {
                doc.text(line, margin + 55, y + 6 + (i * 4));
            });
            
            y += bonusBoxHeight + 4;
            
            // === IDEOLOGIES CARD ===
            const ideoCardHeight = 14;
            drawBox(margin, y, contentWidth, ideoCardHeight, colors.bgMedium, colors.border);
            
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('IDEOLOGIES', margin + 3, y + 7);
            
            let ideoX = margin + 35;
            const ideoY = y + 3.5;
            
            // Faction ideology
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...colors.textLight);
            doc.text('Faction:', ideoX, y + 7);
            ideoX += 15;
            ideoX += drawPill(ideoX, ideoY, state.factionIdeology || '-', colors.pillBgBonus, colors.factionBonus, colors.factionBonus);
            ideoX += 2;
            
            // Role ideology
            doc.setTextColor(...colors.textLight);
            doc.text('Role:', ideoX, y + 7);
            ideoX += 10;
            ideoX += drawPill(ideoX, ideoY, state.roleIdeology || '-', colors.pillBg, colors.primary, colors.primary);
            ideoX += 2;
            
            // Belief ideology
            doc.setTextColor(...colors.textLight);
            doc.text('Belief:', ideoX, y + 7);
            ideoX += 12;
            ideoX += drawPill(ideoX, ideoY, state.beliefIdeology || '-', colors.pillBg, colors.accent, colors.accent);
            ideoX += 2;
            
            // Aversion
            doc.setTextColor(...colors.textLight);
            doc.text('Aversion:', ideoX, y + 7);
            ideoX += 18;
            ideoX += drawPill(ideoX, ideoY, state.aversionIdeology || '-', colors.pillBgAversion, colors.danger, colors.danger);
            
            y += ideoCardHeight + 4;
            
            // === PROFICIENCIES CARD ===
            // First calculate height needed
            const profByIdeology = {};
            state.proficiencies.forEach(p => {
                if (!profByIdeology[p.ideology]) profByIdeology[p.ideology] = [];
                profByIdeology[p.ideology].push(p);
            });
            const profIdeologyCount = Object.keys(profByIdeology).length;
            const profCardHeight = Math.max(18, 12 + (profIdeologyCount * 10));
            
            drawBox(margin, y, contentWidth, profCardHeight, colors.bgMedium, colors.border);
            
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('PROFICIENCIES', margin + 3, y + 7);
            
            let profY = y + 11;
            
            Object.keys(profByIdeology).forEach(ideology => {
                const profs = profByIdeology[ideology];
                const isFavouredIdeology = favoured.includes(ideology);
                const isAversionIdeology = aversions.includes(ideology);
                
                // Ideology label
                doc.setFontSize(8);
                doc.setFont('helvetica', 'bold');
                if (isAversionIdeology) {
                    doc.setTextColor(...colors.danger);
                } else if (!isFavouredIdeology) {
                    doc.setTextColor(...colors.unfavoured);
                } else {
                    doc.setTextColor(...colors.secondary);
                }
                doc.text(ideology + ':', margin + 3, profY + 5);
                
                // Group proficiencies by name
                const profGroups = {};
                profs.forEach(p => {
                    if (!profGroups[p.name]) profGroups[p.name] = [];
                    profGroups[p.name].push(p);
                });
                
                let pillX = margin + 35;
                const grantedUsedLocal = {};
                
                Object.entries(profGroups).forEach(([profName, profList]) => {
                    const key = `${profName}|${ideology}`;
                    const grantedCount = grantedMap.get(key) || 0;
                    const hasChoice = REQUIRES_CHOICE.proficiencies[profName];
                    const choices = getProficiencyChoices(profName, ideology);
                    
                    // Helper to get choice suffix for a specific index
                    const getChoiceSuffix = (idx) => {
                        if (!hasChoice) return '';
                        const choice = choices[idx];
                        return (choice && choice.value) ? ` [${choice.value}]` : ' [TBD]';
                    };
                    
                    // Determine how many are granted vs regular
                    let grantedShown = 0;
                    let regularCount = 0;
                    
                    profList.forEach(p => {
                        const usedLocal = grantedUsedLocal[key] || 0;
                        if (usedLocal < grantedCount) {
                            grantedUsedLocal[key] = usedLocal + 1;
                            grantedShown++;
                        } else {
                            regularCount++;
                        }
                    });
                    
                    // Check if this is bonus or versatile
                    const isBonus = isBonusProficiency(profName, ideology);
                    const versatileChoice = getAdvantageChoice('Versatile');
                    const isVersatile = versatileChoice && versatileChoice.proficiency === profName && versatileChoice.ideology === ideology;
                    
                    let pillIndex = 0;
                    
                    // Draw granted pills (bonus/versatile/other grants) - no symbols, just colored differently
                    if (isBonus && grantedShown > 0) {
                        const text = `${profName}${getChoiceSuffix(pillIndex)}`;
                        pillX += drawPill(pillX, profY, text, colors.pillBgBonus, colors.factionBonus, colors.factionBonus);
                        grantedShown--;
                        pillIndex++;
                    }
                    if (isVersatile && grantedShown > 0) {
                        const text = `${profName}${getChoiceSuffix(pillIndex)}`;
                        pillX += drawPill(pillX, profY, text, colors.pillBgVersatile, colors.versatile, colors.versatile);
                        grantedShown--;
                        pillIndex++;
                    }
                    // Remaining grants (Skilled, Earthling, advantage grants)
                    for (let i = 0; i < grantedShown; i++) {
                        const text = `${profName}${getChoiceSuffix(pillIndex)}`;
                        pillX += drawPill(pillX, profY, text, colors.pillBgVersatile, colors.versatile, colors.versatile);
                        pillIndex++;
                    }
                    
                    // Draw regular pills - each with its own choice
                    if (regularCount > 0) {
                        let bgColor = colors.pillBg;
                        let textColor = colors.primary;
                        let borderColor = colors.primary;
                        
                        if (isAversionIdeology) {
                            bgColor = colors.pillBgAversion;
                            textColor = colors.danger;
                            borderColor = colors.danger;
                        } else if (!isFavouredIdeology) {
                            bgColor = colors.pillBgUnfavoured;
                            textColor = colors.unfavoured;
                            borderColor = colors.unfavoured;
                        }
                        
                        // Draw each regular instance with its own choice
                        for (let i = 0; i < regularCount; i++) {
                            const text = `${profName}${getChoiceSuffix(pillIndex)}`;
                            pillX += drawPill(pillX, profY, text, bgColor, textColor, borderColor);
                            pillIndex++;
                        }
                    }
                });
                
                profY += 10;
            });
            
            y += profCardHeight + 4;
            
            // === ADVANTAGES & DRAWBACKS CARD (side by side) ===
            // Calculate heights needed
            let advHeight = 8;
            const advCounts = {};
            state.advantages.forEach(name => advCounts[name] = (advCounts[name] || 0) + 1);
            const advUnique = [...new Set(state.advantages)];
            advUnique.forEach(name => {
                advHeight += 4;
                if (REQUIRES_CHOICE.advantages[name]) advHeight += 3;
            });
            if (state.advantages.length === 0) advHeight += 4;
            
            let drawHeight = 8;
            const drawCounts = {};
            state.drawbacks.forEach(name => drawCounts[name] = (drawCounts[name] || 0) + 1);
            const drawUnique = [...new Set(state.drawbacks)];
            drawUnique.forEach(name => {
                drawHeight += 4;
                if (REQUIRES_CHOICE.drawbacks[name]) drawHeight += 3;
            });
            if (state.drawbacks.length === 0) drawHeight += 4;
            
            const advDrawCardHeight = Math.max(advHeight, drawHeight) + 4;
            const advDrawColWidth = (contentWidth - 6) / 2;
            
            drawBox(margin, y, contentWidth, advDrawCardHeight, colors.bgMedium, colors.border);
            
            doc.setFontSize(8);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('ADVANTAGES', margin + 3, y + 6);
            doc.text('DRAWBACKS', margin + advDrawColWidth + 6, y + 6);
            
            let advY = y + 10;
            
            // Advantages
            advUnique.forEach(name => {
                const adv = ADVANTAGES.find(a => a.name === name);
                const isBonus = isBonusAdvantage(name);
                const count = advCounts[name];
                const choice = getAdvantageChoice(name);
                
                doc.setFontSize(6);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(...(isBonus ? colors.factionBonus : colors.text));
                
                let advText = `• ${name}`;
                if (count > 1) advText += ` ×${count}`;
                // No star symbol - just yellow color indicates bonus
                doc.text(advText, margin + 3, advY);
                advY += 4;
                
                // Show choice if needed - check various choice types
                let choiceLines = [];
                
                // Special case: Ideologist shows secondary ideologies on two lines
                if (name === 'Ideologist') {
                    if (state.secondBeliefIdeology) {
                        choiceLines.push(`Belief: ${state.secondBeliefIdeology}`);
                    }
                    if (state.secondAversionIdeology) {
                        choiceLines.push(`Aversion: ${state.secondAversionIdeology}`);
                    }
                    if (choiceLines.length === 0) {
                        choiceLines.push('[TBD]');
                    }
                }
                // Special case: Versatile shows chosen proficiency
                else if (name === 'Versatile' && choice) {
                    if (choice.proficiency && choice.ideology) {
                        choiceLines.push(`${choice.proficiency} (${choice.ideology})`);
                    } else {
                        choiceLines.push('[TBD]');
                    }
                }
                // Other choices from REQUIRES_CHOICE
                else if (REQUIRES_CHOICE.advantages[name]) {
                    if (choice) {
                        if (name === 'Rising Star' && choice.favored) {
                            choiceLines.push(`+3: ${choice.favored}`);
                        } else if (choice.text) {
                            choiceLines.push(choice.text);
                        } else if (Array.isArray(choice) && choice[0]?.text) {
                            choiceLines.push(choice.map(c => c.text).join(', '));
                        } else if (Array.isArray(choice) && choice[0]?.proficiency) {
                            choiceLines.push(choice.map(c => c.proficiency).join(', '));
                        } else if (Array.isArray(choice) && choice[0]?.name) {
                            choiceLines.push(choice.map(c => c.name).join(', '));
                        } else if (choice.proficiencies) {
                            choiceLines.push(choice.proficiencies.filter(p => p.name).map(p => p.name).join(', '));
                        } else if (choice.proficiency) {
                            choiceLines.push(choice.proficiency);
                        } else if (choice.subgroup) {
                            choiceLines.push(choice.subgroup);
                        }
                    } else {
                        choiceLines.push('[TBD]');
                    }
                }
                
                if (choiceLines.length > 0) {
                    doc.setFontSize(5);
                    doc.setTextColor(160, 170, 180); // Lighter gray
                    choiceLines.forEach(line => {
                        doc.text(`  ${line}`, margin + 3, advY);
                        advY += 3;
                    });
                }
            });
            
            if (state.advantages.length === 0) {
                doc.setFontSize(6);
                doc.setTextColor(...colors.textLight);
                doc.text('None', margin + 3, advY);
            }
            
            // Drawbacks
            let drawY = y + 10;
            
            drawUnique.forEach(name => {
                const draw = DRAWBACKS.find(d => d.name === name);
                const count = drawCounts[name];
                const choice = getDrawbackChoice(name);
                
                doc.setFontSize(6);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor(...colors.text);
                
                let drawText = `• ${name}`;
                if (count > 1) drawText += ` ×${count}`;
                doc.text(drawText, margin + advDrawColWidth + 6, drawY);
                drawY += 4;
                
                // Show choice if needed
                let choiceText = null;
                if (REQUIRES_CHOICE.drawbacks[name]) {
                    if (choice && choice.text) {
                        choiceText = choice.text;
                    } else if (Array.isArray(choice) && choice[0]?.text) {
                        choiceText = choice.map(c => c.text).join(', ');
                    } else if (choice && choice.subgroup) {
                        choiceText = choice.subgroup;
                    } else {
                        choiceText = '[TBD]';
                    }
                }
                
                if (choiceText) {
                    doc.setFontSize(5);
                    doc.setTextColor(160, 170, 180); // Lighter gray
                    doc.text(`  ${choiceText}`, margin + advDrawColWidth + 6, drawY);
                    drawY += 3;
                }
            });
            
            if (state.drawbacks.length === 0) {
                doc.setFontSize(6);
                doc.setTextColor(...colors.textLight);
                doc.text('None', margin + advDrawColWidth + 6, drawY);
            }
            
            y += advDrawCardHeight + 4;
            
            // === RESOURCES CARD ===
            const totalIncome = getTotalIncome();
            const nutrientIncome = getNutrientIncome();
            const mineralIncome = getMineralIncome();
            const breakthroughs = getBreakthroughs();
            const facilities = getFacilities();
            
            // Calculate character upkeep (energy cost per session)
            // Hive: 0, Morgan: 2 required + 2 optional, Everyone else: 2
            // Benefactor removes the base 2 upkeep
            const isHive = state.faction === 'hive';
            const isMorgan = state.faction === 'morgan';
            const hasBenefactor = state.advantages.includes('Benefactor');
            const requiredUpkeep = (isHive || hasBenefactor) ? 0 : 2;
            const optionalUpkeep = isMorgan ? 2 : 0;
            
            // Check if we need extra row for Breakthroughs/Facilities
            const hasExtraResources = breakthroughs > 0 || facilities > 1;
            const resourceCardHeight = hasExtraResources ? 30 : 22;
            
            drawBox(margin, y, contentWidth, resourceCardHeight, colors.bgMedium, colors.border);
            
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('RESOURCES', margin + 3, y + 7);
            
            // Aligned columns
            const resCol1 = margin + 30;
            const resCol2 = margin + 105;
            
            doc.setFontSize(7);
            doc.setFont('helvetica', 'normal');
            
            // Helper function to draw resource pips or overflow bar
            function drawResourcePips(startX, yPos, amount, fillColor) {
                const pipSize = 4;
                const pipGap = 2;
                const totalWidth = 6 * pipSize + 5 * pipGap; // Total width of 6 pips with gaps
                
                if (amount > 6) {
                    // Draw solid filled bar
                    doc.setFillColor(...fillColor);
                    doc.setDrawColor(...colors.textLight);
                    doc.setLineWidth(0.3);
                    doc.rect(startX, yPos, totalWidth, pipSize, 'FD'); // Fill and draw border
                    
                    // Show total number inside the bar in bold (dark text for contrast)
                    doc.setFontSize(7);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(0, 0, 0); // Black text for contrast
                    doc.text(`${amount}`, startX + totalWidth / 2, yPos + 3.2, { align: 'center' });
                    doc.setFont('helvetica', 'normal');
                } else {
                    // Draw individual pips
                    let x = startX;
                    for (let i = 0; i < 6; i++) {
                        doc.setDrawColor(...colors.textLight);
                        doc.setLineWidth(0.3);
                        doc.rect(x, yPos, pipSize, pipSize, 'S');
                        if (i < amount) {
                            doc.setFillColor(...fillColor);
                            doc.rect(x + 0.5, yPos + 0.5, pipSize - 1, pipSize - 1, 'F');
                        }
                        x += pipSize + pipGap;
                    }
                }
            }
            
            // Row 1: Upkeep (red pips) and Nutrients (with income)
            const pipsCol1 = margin + 45;
            const pipsCol2 = margin + 120;
            const labelCol1 = pipsCol1 - 2;  // Right-align labels just before pips
            const labelCol2 = pipsCol2 - 2;
            
            doc.setTextColor(...colors.danger);
            doc.text('Upkeep:', labelCol1, y + 7, { align: 'right' });
            resX = pipsCol1;
            for (let i = 0; i < 6; i++) {
                let fillColor = null;
                if (i < requiredUpkeep) {
                    fillColor = colors.danger; // Red for required upkeep
                } else if (i < requiredUpkeep + optionalUpkeep) {
                    fillColor = colors.warning; // Orange for optional (Morgan)
                }
                resX += drawCheckbox(resX, y + 4, fillColor !== null, fillColor);
            }
            
            // Nutrients with income
            const nutrientColor = [80, 220, 80]; // Bright green for nutrients
            doc.setTextColor(...(nutrientIncome > 0 ? nutrientColor : colors.text));
            doc.text('Nutrients:', labelCol2, y + 7, { align: 'right' });
            drawResourcePips(pipsCol2, y + 4, nutrientIncome, nutrientColor);
            
            // Row 2: Energy (income) and Minerals (with income)
            doc.setTextColor(...colors.energy);
            doc.text('Energy:', labelCol1, y + 15, { align: 'right' });
            drawResourcePips(pipsCol1, y + 12, totalIncome, colors.energy);
            
            // Minerals with income
            const mineralColor = [200, 150, 100]; // Warmer brown for minerals
            doc.setTextColor(...(mineralIncome > 0 ? mineralColor : colors.text));
            doc.text('Minerals:', labelCol2, y + 15, { align: 'right' });
            drawResourcePips(pipsCol2, y + 12, mineralIncome, mineralColor);
            
            // Row 3: Breakthroughs and Facilities (only if applicable)
            if (hasExtraResources) {
                const breakthroughColor = [200, 150, 255]; // Purple for breakthroughs
                const facilityColor = [180, 180, 190]; // Light grey for facilities
                
                if (breakthroughs > 0) {
                    doc.setTextColor(...breakthroughColor);
                    doc.text('Breakthroughs:', labelCol1, y + 23, { align: 'right' });
                    drawResourcePips(pipsCol1, y + 20, breakthroughs, breakthroughColor);
                }
                
                if (facilities > 1) {
                    doc.setTextColor(...facilityColor);
                    doc.text('Facilities:', labelCol2, y + 23, { align: 'right' });
                    drawResourcePips(pipsCol2, y + 20, facilities, facilityColor);
                }
            }
            
            y += resourceCardHeight + 4;
            
            // === XP CARD with breakdown ===
            const advXP = getTotalAdvXP();
            const drawXP = getTotalDrawXP();
            const bonusXP = faction.bonusXP || 0;
            const profXP = getExtraProficiencyXPCost();
            const netXP = bonusXP + drawXP - advXP - profXP;
            
            drawBox(margin, y, contentWidth, 12, colors.bgMedium, colors.border);
            
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...colors.primary);
            doc.text('XP', margin + 3, y + 8);
            
            // Formula: Starting XP + Drawbacks - Advantages - Proficiencies = Net
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(7);
            let xpX = margin + 15;
            
            // Starting XP (0 unless faction bonus)
            doc.setTextColor(...colors.factionBonus);
            doc.text(`${bonusXP}`, xpX, y + 8);
            xpX += doc.getTextWidth(`${bonusXP}`) + 2;
            
            // + Drawbacks
            doc.setTextColor(...colors.text);
            doc.text('+', xpX, y + 8);
            xpX += 5;
            doc.setTextColor(...colors.danger);
            doc.text(`${drawXP}`, xpX, y + 8);
            xpX += doc.getTextWidth(`${drawXP}`) + 2;
            
            // - Advantages
            doc.setTextColor(...colors.text);
            doc.text('-', xpX, y + 8);
            xpX += 4;
            doc.setTextColor(...colors.secondary);
            doc.text(`${advXP}`, xpX, y + 8);
            xpX += doc.getTextWidth(`${advXP}`) + 2;
            
            // - Proficiencies
            doc.setTextColor(...colors.text);
            doc.text('-', xpX, y + 8);
            xpX += 4;
            doc.setTextColor(...colors.primary);
            doc.text(`${profXP}`, xpX, y + 8);
            xpX += doc.getTextWidth(`${profXP}`) + 3;
            
            // = Net
            doc.setTextColor(...colors.text);
            doc.text('=', xpX, y + 8);
            xpX += 5;
            
            // Net XP result
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(netXP >= 0 ? colors.accent[0] : colors.danger[0], netXP >= 0 ? colors.accent[1] : colors.danger[1], netXP >= 0 ? colors.accent[2] : colors.danger[2]);
            doc.text(`${netXP >= 0 ? '+' : ''}${netXP} XP`, xpX, y + 8);
            
            // Labels below the numbers
            doc.setFontSize(5);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(...colors.textLight);
            let labelX = margin + 15;
            doc.text('start', labelX, y + 11);
            labelX += doc.getTextWidth(`${bonusXP}`) + 7;
            doc.text('draw', labelX, y + 11);
            labelX += doc.getTextWidth(`${drawXP}`) + 6;
            doc.text('adv', labelX, y + 11);
            labelX += doc.getTextWidth(`${advXP}`) + 6;
            doc.text('prof', labelX, y + 11);
            
            // Footer
            addFooter();
            
            // Save
            doc.save(`${state.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_character_sheet.pdf`);
        }
        
        function importCharacter() {
            document.getElementById('importFile').click();
        }
        
        function handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    loadCharacter(data);
                } catch (err) {
                    alert('Error loading file: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }
        
        function loadCharacter(data) {
            const char = data.character;
            
            document.getElementById('charName').value = char.name || '';
            document.getElementById('charConcept').value = char.concept || '';
            state.concept = char.concept || '';
            updateConceptCounter();
            
            // Load advantages and drawbacks first (needed for Faction Rebel)
            state.advantages = char.advantages.map(a => a.name) || [];
            state.drawbacks = char.drawbacks.map(d => d.name) || [];
            
            // Load spartan choice if applicable
            if (char.spartanChoice) {
                state.spartanChoice = char.spartanChoice;
            }
            
            // Load choices - prefer raw choice objects if available (v1.3+)
            state.proficiencyChoices = {};
            state.advantageChoices = {};
            state.drawbackChoices = {};
            
            // Restore proficiency choices
            if (char.proficiencyChoices) {
                // v1.3+ format - direct restore
                state.proficiencyChoices = char.proficiencyChoices;
            } else if (char.proficiencies) {
                // Legacy format - rebuild from proficiency list
                const profChoiceArrays = {};
                char.proficiencies.forEach(p => {
                    if (p.choice) {
                        const key = getProficiencyChoiceKey(p.name, p.ideology);
                        if (!profChoiceArrays[key]) profChoiceArrays[key] = [];
                        const idx = p.instanceIndex || profChoiceArrays[key].length;
                        profChoiceArrays[key][idx] = p.choice;
                    }
                });
                state.proficiencyChoices = profChoiceArrays;
            }
            
            // Restore advantage choices
            if (char.advantageChoices) {
                // v1.3+ format - direct restore
                state.advantageChoices = char.advantageChoices;
            } else if (char.advantages) {
                // Legacy format - rebuild from advantage list
                char.advantages.forEach(a => {
                    if (a.choice) {
                        const config = REQUIRES_CHOICE.advantages?.[a.name];
                        if (config?.multiple || ['Practiced', 'Skilled', 'Notable'].includes(a.name)) {
                            // Array-based choice
                            if (!state.advantageChoices[a.name]) {
                                state.advantageChoices[a.name] = [];
                            }
                            const idx = a.instanceIndex || state.advantageChoices[a.name].length;
                            state.advantageChoices[a.name][idx] = a.choice;
                        } else {
                            // Single choice
                            state.advantageChoices[a.name] = a.choice;
                        }
                    }
                });
            }
            
            // Restore drawback choices
            if (char.drawbackChoices) {
                // v1.3+ format - direct restore
                state.drawbackChoices = char.drawbackChoices;
            } else if (char.drawbacks) {
                // Legacy format - rebuild from drawback list
                char.drawbacks.forEach(d => {
                    if (d.choice) {
                        const config = REQUIRES_CHOICE.drawbacks?.[d.name];
                        if (config?.multiple) {
                            // Array-based choice
                            if (!state.drawbackChoices[d.name]) {
                                state.drawbackChoices[d.name] = [];
                            }
                            const idx = d.instanceIndex || state.drawbackChoices[d.name].length;
                            state.drawbackChoices[d.name][idx] = d.choice;
                        } else {
                            // Single choice
                            state.drawbackChoices[d.name] = d.choice;
                        }
                    }
                });
            }
            
            document.getElementById('faction').value = char.faction.key;
            updateFactionInfo();
            
            // If Faction Rebel, set custom faction ideology
            if (state.drawbacks.includes('Faction Rebel') && char.ideologies.faction) {
                state.factionIdeology = char.ideologies.faction;
                document.getElementById('customFactionIdeology').value = char.ideologies.faction;
                updateFactionIdeologyDisplay();
                updateFactionRebelSelector();
            }
            
            document.getElementById('roleIdeology').value = char.ideologies.role;
            updateBeliefOptions();
            
            document.getElementById('beliefIdeology').value = char.ideologies.belief;
            updateAversionOptions();
            
            document.getElementById('aversionIdeology').value = char.ideologies.aversion;
            state.aversionIdeology = char.ideologies.aversion;
            showIdeologyDesc('aversionIdeologyDesc', state.aversionIdeology, true);
            
            // Restore proficiencies (just name and ideology)
            state.proficiencies = char.proficiencies.map(p => ({
                name: p.name,
                ideology: p.ideology
            })) || [];
            
            // Secondary ideologies
            if (char.ideologies.secondBelief) {
                state.secondBeliefIdeology = char.ideologies.secondBelief;
            }
            if (char.ideologies.secondAversion) {
                state.secondAversionIdeology = char.ideologies.secondAversion;
            }
            
            state.currentProfTab = null;
            
            updateSecondaryIdeologies();
            if (state.secondBeliefIdeology) {
                document.getElementById('secondBeliefIdeology').value = state.secondBeliefIdeology;
                showIdeologyDesc('secondBeliefIdeologyDesc', state.secondBeliefIdeology);
            }
            if (state.secondAversionIdeology) {
                document.getElementById('secondAversionIdeology').value = state.secondAversionIdeology;
                showIdeologyDesc('secondAversionIdeologyDesc', state.secondAversionIdeology, true);
            }
            
            // Update spartan choice dropdown if applicable
            if (state.faction === 'spartans' && state.spartanChoice) {
                const spartanSelect = document.getElementById('spartanChoice');
                if (spartanSelect) {
                    spartanSelect.value = state.spartanChoice.name;
                }
            }
            
            updateProficiencyTabs();
            renderAdvantages();
            renderDrawbacks();
            updateXP();
            validate();
        }
        
        window.resetForm = function() {
            if (!confirm('Reset all character data?')) {
                return;
            }
            
            // Reset state
            state.name = '';
            state.concept = '';
            state.faction = '';
            state.factionIdeology = '';
            state.roleIdeology = '';
            state.beliefIdeology = '';
            state.aversionIdeology = '';
            state.secondBeliefIdeology = '';
            state.secondAversionIdeology = '';
            state.proficiencies = [];
            state.advantages = [];
            state.drawbacks = [];
            state.currentProfTab = null;
            state.spartanChoice = null;
            state.proficiencyChoices = {};
            state.advantageChoices = {};
            state.drawbackChoices = {};
            
            // Reset form fields
            document.getElementById('charName').value = '';
            document.getElementById('charConcept').value = '';
            updateConceptCounter();
            document.getElementById('faction').value = '';
            document.getElementById('roleIdeology').value = '';
            document.getElementById('beliefIdeology').value = '';
            document.getElementById('aversionIdeology').value = '';
            
            // Hide descriptions
            ['factionIdeologyDesc', 'roleIdeologyDesc', 'beliefIdeologyDesc', 'aversionIdeologyDesc', 'secondBeliefIdeologyDesc', 'secondAversionIdeologyDesc'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.classList.remove('visible');
                    el.innerHTML = '';
                }
            });
            
            // Hide sections
            document.getElementById('secondaryIdeologies').style.display = 'none';
            document.getElementById('factionRebelSelect').style.display = 'none';
            document.getElementById('factionBonusInfo').style.display = 'none';
            
            // Clear proficiency display
            document.getElementById('profTabs').innerHTML = '<span style="color: var(--text-dim); font-size: 0.85em;">Select ideologies first</span>';
            document.getElementById('profTabContent').innerHTML = '';
            document.getElementById('proficiencyRequirements').innerHTML = '';
            document.getElementById('profEffects').innerHTML = '';
            document.getElementById('selectedProfs').innerHTML = '<span style="color: var(--text-dim); font-size: 0.85em;">None selected</span>';
            document.getElementById('profCounter').textContent = '(0)';
            document.getElementById('profCounter').className = 'counter';
            
            // Update displays
            updateFactionInfo();
            renderAdvantages();
            renderDrawbacks();
            updateXP();
            validate();
        };
        
        // Event Listeners
        document.getElementById('faction')?.addEventListener('change', updateFactionInfo);
        document.getElementById('roleIdeology')?.addEventListener('change', updateBeliefOptions);
        document.getElementById('beliefIdeology')?.addEventListener('change', updateAversionOptions);
        document.getElementById('aversionIdeology')?.addEventListener('change', updateAversion);
        document.getElementById('charName')?.addEventListener('input', validate);
        document.getElementById('charConcept')?.addEventListener('input', () => {
            state.concept = document.getElementById('charConcept').value;
            updateConceptCounter();
        });
        
        function updateConceptCounter() {
            const textarea = document.getElementById('charConcept');
            const counter = document.getElementById('conceptCounter');
            if (!textarea || !counter) return;
            
            const len = textarea.value.length;
            const max = 1200;
            counter.textContent = `(${len}/${max})`;
            
            if (len >= max) {
                counter.className = 'char-counter danger';
            } else if (len >= max * 0.9) {
                counter.className = 'char-counter warning';
            } else {
                counter.className = 'char-counter';
            }
        }
        
        // Initialize counter
        updateConceptCounter();
        
        document.getElementById('secondBeliefIdeology')?.addEventListener('change', (e) => {
            state.secondBeliefIdeology = e.target.value;
            showIdeologyDesc('secondBeliefIdeologyDesc', state.secondBeliefIdeology);
            clearInvalidProficiencies();
            updateSecondaryIdeologies();
            updateProficiencyTabs();
            validate();
        });
        
        document.getElementById('secondAversionIdeology')?.addEventListener('change', (e) => {
            state.secondAversionIdeology = e.target.value;
            showIdeologyDesc('secondAversionIdeologyDesc', state.secondAversionIdeology, true);
            clearInvalidProficiencies();
            updateProficiencyTabs();
            validate();
        });
        
        document.getElementById('customFactionIdeology')?.addEventListener('change', (e) => {
            const newIdeology = e.target.value;
            const oldIdeology = state.factionIdeology;
            
            if (newIdeology !== oldIdeology) {
                state.factionIdeology = newIdeology;
                updateFactionIdeologyDisplay();
                clearInvalidProficiencies();
                updateRoleOptions();
                updateProficiencyTabs();
                validate();
            }
        });
        
        // Reset button
        document.getElementById('resetBtn')?.addEventListener('click', function(e) {
            e.preventDefault();
            window.resetForm();
        });
        
        // Initialize
        renderAdvantages();
        renderDrawbacks();
        updateXP();
        validate();
    </script>
</body>
</html>
